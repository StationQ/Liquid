<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Liquid1</name>
  </assembly>
  <members>
    <member name="T:Microsoft.Research.Liquid.App">
      <summary>
 Utilities for executing the Liquid application.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.App.RunLiquid">
      <summary>
 The main routine for running Liquid.
 This function gets the command-line parameters from the environment,
 parses them, and executes the requested Liquid method.
 </summary>
      <returns>0 if execution succeeded, or 1 if an error occured.</returns>
    </member>
    <member name="T:Microsoft.Research.Liquid.Bit">
      <summary>
 Represents the measured value, in the computational basis, of a qubit.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Bit.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dumps the measured value.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Bit.ToString">
      <summary>
 Gets a string representation of this value.
 The string will be "Zero", "One", or "?".
 </summary>
      <returns>The string</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Bit.v">
      <summary>
 The integer value of a measured qubit, either 0 or 1.
 Note that this property will throw an exception if the value is unknown.
 </summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.Circuit">
      <summary>
 The circuit representation of an operation in a quantum algorithm.
 Circuits are generally created using 
 <see cref="M:Microsoft.Research.Liquid.Circuit.Compile(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">Circuit.Compile</see>.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.Compile(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Compiles a function implemented as a sequence of gate function calls into a Circuit.
 </summary>
      <param name="f">The gate function to compile.</param>
      <param name="qs">The qubits the new Circuit will operate on.</param>
      <returns>A new Circuit that represents the function calls</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dumps this circuit recursively to the console and/or log.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.FindIds(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Find Ids below this point and the time needed to execute the circuit (internal)
 </summary>
      <param name="detail">What level of detail for when we hit a "Wrap" gate</param>
      <param name="cntEmpty">An option allowing Empty gates to be counted like Native
 The default is false, which is to not count Empty gates as Native.</param>
      <returns>Set of ids,total time to execute</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.Fold(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Rewrites this circuit by identifying opportunities for parallelism and turning Seq elements
 into Par elements where possible.
 This makes for a better rendering.
 </summary>
      <param name="agressive">An option to fold as much as possible by decomposing this circuit
 into basic gates before folding. 
 The default is to not decompose Wrap gates and other aggregates before folding.</param>
      <returns>The new folded circuit</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.GateCount(Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Gate,System.Boolean}})">
      <summary>
 Gets the count of gates in circuit.
 Note that pure label gates -- that is, gates of type String -- are never counted.
 </summary>
      <param name="doParallel">An option to only count the longest sub-circuit of
 a parallel component, rather than adding all gates in all components.
 This is useful when computing gate depth.
 The default is false, which counts all gates, summing over parallel sub-circuits.</param>
      <param name="gMatch">An optional function to filter which gates should be counted.
 If a match function is provided, only gates that return true are included in the count.
 The default is to count all non-String gates.</param>
      <returns>The count of low-level gates in the circuit</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.Grow(Microsoft.Research.Liquid.Ket,Microsoft.Research.Liquid.GrowPars)">
      <summary>
 Creates an optimized "grown" version of this Circuit.
 The type and limits of the conversion are specified in the grow parameter.
 </summary>
      <param name="k">A Ket this Circuit could be run with.</param>
      <param name="gp">The grow parameters to use.
 See the <see cref="T:Microsoft.Research.Liquid.GrowPars">GrowPars</see> type for details.</param>
      <returns>A new, optimized Circuit</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">
      <summary>
 Creates an equivalent circuit to this circuit by aggregating existing unitary gates into larger unitary gates.
 The new circuit will execute faster because it has fewer matrix applications required.
 </summary>
      <param name="k">A Ket this Circuit could be run with.</param>
      <param name="gp">Optional grow parameters.
 The default is to use all of the GrowPars defaults.
 See the <see cref="T:Microsoft.Research.Liquid.GrowPars">GrowPars</see> type for details.</param>
      <returns>New optimized Circuit</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.GrowSingle(Microsoft.Research.Liquid.GrowPars)">
      <summary>
 Converts this circuit into a single unitary gate, implemented by a single matrix.
 This allows maximum optimization of circuit execution.
 <para>
 This circuit must be completely unitary to be converted into a single matrix.
 If it is not, an exception will be raised by this method.
 </para></summary>
      <param name="gp">Optional grow parameters.
 The default is to use all of the GrowPars defaults.
 See the <see cref="T:Microsoft.Research.Liquid.GrowPars">GrowPars</see> type for details.</param>
      <returns>The new single-gate Circuit</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Circuit.NotEmpty">
      <summary>
 Is this Circuit element not the "Empty" circuit.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.RemoveRedund">
      <summary>
 Creates a new circuit logically equivalent to this circuit, but with redundant gates removed.
 For instance, if this routine found a sequence of two X gates in succession on the same qubit,
 it would remove both of them from the result.
 </summary>
      <returns>The new, trimmed circuit</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.Render(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double})">
      <summary>
 Renders this circuit to a file.
 </summary>
      <param name="file">The full name of the file to create, including the extension.</param>
      <param name="typ">The optional format for the rendered graphics. Possible values are:
 <ul><li><b>"qc"</b>: QCircuit Liquid format</li><li><b>"tikz"</b>: TikZ Liquid format for TeX and LaTeX</li><li><b>"svg"</b>: Vector graphics format for HTML</li></ul>
 The default is "svg".</param>
      <param name="detail">An option specifying how many levels of Wrap to unwrap.
 The default is 999.</param>
      <param name="split">An option specifying what percentage of the total gates should go into each figure,
 if the circuit won't fit into a single figure.
 The default value varies with the figure size.</param>
      <param name="scale">An option specifying a scaling percentage for the rendering, with 100.0 being full size.
 The default value varies with the figure size.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.RenderHT(System.String,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double})">
      <summary>
 Renders a circuit to both svg, for HTML, and tikz, for TeX.
 <seealso cref="M:Microsoft.Research.Liquid.Circuit.Render(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double})" /></summary>
      <param name="file">The base name of the files to create.
 Appropriate extensions will be added for the created files: ".htm" for the
 SVG rendering, and ".tex" for the TikZ rendering.</param>
      <param name="detail">An option specifying how many levels of Wrap to unwrap.
 The default is 999.</param>
      <param name="split">An option specifying what percentage of the total gates should go into each figure,
 if the circuit won't fit into a single figure.
 The default value varies with the figure size.</param>
      <param name="scale">An option specifying a scaling percentage for the rendering, with 100.0 being full size.
 The default value varies with the figure size.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.Reverse">
      <summary>
 Reverses this circuit, which must contain only unitary gates.
 In addition, bottom-level gates are replaced by their adjoints.
 This method will raise an exception if this circuit contains a non-unitary gate.
 </summary>
      <returns>The resulting reversed circuit</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.Run(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Runs this Circuit.
 The state of the Ket containing the passed-in qubits will be modified.
 </summary>
      <param name="qs">The list of Qubits to operate on.
 These must correspond to the qubits the circuit was compiled with;
 that is, they must have the same qubit IDs as those.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.ToString">
      <summary>
 Returns a string representing the current circuit element. 
 </summary>
      <returns>The string representation</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Circuit.Wires">
      <summary>
 Gets the list of wires (qubit IDs) touched by this circuit.
 </summary>
      <returns>A list of the wires used</returns>
    </member>
    <member name="T:Microsoft.Research.Liquid.CMat">
      <summary>
 A dense matrix of complex numbers.
 <seealso cref="T::Microsoft.Research.Liquid.CSMat" /></summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.#ctor(System.Double[][],System.Double[][])">
      <summary>
 Creates a new matrix from arrays of real and imaginary parts.
 </summary>
      <param name="rs">The real part of each matrix element.</param>
      <param name="is">The real part of each matrix element.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.#ctor(System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32,System.Double,System.Double}})">
      <summary>
 Creates a square matrx from a sparse list of elements.
 </summary>
      <param name="len">The row (or column) length of the matrix.</param>
      <param name="xyris">A list of element location and value tuples,
 with elements in the order (row,col,real,imag).</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.#ctor(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Creates a square identity or zero matrix.
 </summary>
      <param name="n">The row (or column) length of the matrix.</param>
      <param name="zero">Option to initialize to a zero matrix rather than to the identity matrix. 
 The default is to initialize to the identity.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Add(Microsoft.Research.Liquid.CMat)">
      <summary>
 Adds another matrix to this matrix.
 The two matrices must have the same number of rows and columns.
 </summary>
      <param name="m2">The matrix to add to this one.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Adj">
      <summary>
 Computes the adjoint (complex conjugate transpose) of this matrix.
 </summary>
      <returns>The adjoint matrix</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Clear">
      <summary>
 Clears this matrix, setting it to a 0x0 matrix.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Copy">
      <summary>
 Makes a new copy, independent copy of this matrix.
 </summary>
      <returns>The new matrix</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.CreMat(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Double}})">
      <summary>
 Creates an array that can be filled in and passed to the 
 <see cref="M:Microsoft.Research.Liquid.CMat.#ctor(System.Double[][],System.Double[][])">array-based CMat constructor</see>.
 </summary>
      <param name="lenR">The number of rows</param>
      <param name="lenC">The number of columns</param>
      <param name="f">The function to call to compute the elements of the array.
 It will get called with the row first and then the column (curried).</param>
      <returns>The new array</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.CreZer(System.Int32,System.Int32)">
      <summary>
 Creates an array filled with zeros that can be filled in and passed to the 
 <see cref="M:Microsoft.Research.Liquid.CMat.#ctor(System.Double[][],System.Double[][])">array-based CMat constructor</see>.
 </summary>
      <param name="lenR">The number of rows</param>
      <param name="lenC">The number of columns</param>
      <returns>The new array</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Div(System.Double)">
      <summary>
 Scales this matrix by a constant divisor.
 This matrix is updated in place, rather than a new matrix being created.
 </summary>
      <param name="div">The scale divisor. The matrix is multiplied by 1/div.</param>
      <returns>This matrix, as updated after scaling</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dumps this matrix.
 Note that there is no limit on the size of the result; every row and column entry is included.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.DumpML(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dumps this matrix in Matlab format for debugging.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
      <param name="prec">precision 0=low 1=normal 2=high 3=full (optional=1)</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.DumpNarrow(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dumps this matrix.
 This method will produce a relatively compact representation of the matrix.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.FixUnitary(Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Makes this matrix closer to being unitary by applying an iterative correction.
 </summary>
      <param name="tol">An optional desired tolerance for the deviation from unitarity,
 as measured by <see cref="M:Microsoft.Research.Liquid.CMat.UnitaryError"></see>. 
 The default is 1.0e-13.</param>
      <param name="maxIter">An optional maximum number of iterations to perform.
 The default is 5.</param>
      <returns>A tuple of the number of iterations performed, for cost estimates, 
 and the final deviation from unitarity.</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.CMat.Item(System.Int32,System.Int32)">
      <summary>
 Gets an individual element of the matrix, as a Complex number.
 </summary>
      <param name="i">The row index.</param>
      <param name="j">The column index.</param>
      <returns>The complex value of the matrix element.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Kron(Microsoft.Research.Liquid.CMat)">
      <summary>
 Computes the Kronecker Product of this matrix with another matrix.
 </summary>
      <param name="m2">The right-hand side matrix in the Kronecker product.</param>
      <returns>The result of the Kronecker product</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Kron(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Computes the Kronecker Product of this matrix with an identity matrix
 </summary>
      <param name="len">The dimension of the identity matrix (N of NxN).</param>
      <param name="left">An option that, if true, specifies that the identity matrix
 should be on the left side of the Kronecker product.
 The default is false, which means that the identity is on the right.</param>
      <returns>The result of the Kronecker product</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.CMat.Length">
      <summary>
 The number of rows or columns in the matrix, for square matrices.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.CMat.LengthC">
      <summary>
 The number of columns in the matrix.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.CMat.LengthR">
      <summary>
 The number of rows in the matrix.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Mul(Microsoft.Research.Liquid.CMat)">
      <summary>
 Computes the product of this matrix with another matrix.
 This matrix is on the left-hand side of the product, 
 and the argument matrix is on the right-hand side.
 This matrix must have the same number of columns as the other matrix has rows.
 </summary>
      <param name="m2">The second matrix.</param>
      <returns>The resulting product matrix.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Mul(Microsoft.Research.Liquid.CVec)">
      <summary>
 Calculates the product of this matrix and a vector.
 The vector's length must match the numder of columns in this matrix.
 </summary>
      <param name="v">The vector to multiply</param>
      <returns>The resulting product vector</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Mul(System.Double)">
      <summary>
 Scales this matrix by a constant multiplier.
 This matrix is updated in place, rather than a new matrix being created.
 </summary>
      <param name="mul">The scale factor to multiply by.</param>
      <returns>This matrix, as updated after scaling</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.op_AdditionAssignment(Microsoft.Research.Liquid.CMat,Microsoft.Research.Liquid.CMat)">
      <summary>
 Adds one matrix to another.
 </summary>
      <param name="m1">The left matrix. This matrix is modified.</param>
      <param name="m2">The right matrix</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.op_DivisionAssignment(Microsoft.Research.Liquid.CMat,System.Double)">
      <summary>
 Scales a matrix by a constant divisor.
 The matrix is updated in place, rather than a new matrix being created.
 </summary>
      <param name="m1">The matrix to scale.</param>
      <param name="div">The scale divisor. The matrix is multiplied by 1/div.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.op_Multiply(Microsoft.Research.Liquid.CMat,Microsoft.Research.Liquid.CMat)">
      <summary>
 Computes the product of two matrices.
 The first matrix must have the same number of columns as the second matrix has rows.
 </summary>
      <param name="m1">The left (first) matrix</param>
      <param name="m2">The right (second) matrix</param>
      <returns>The resulting product matrix</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.op_Multiply(Microsoft.Research.Liquid.CMat,Microsoft.Research.Liquid.CVec)">
      <summary>
 Computes the product of a matrix and a vector.
 The vector's length must match the numder of columns in the matrix.
 </summary>
      <param name="m">The matrix</param>
      <param name="v">The vector</param>
      <returns>The resulting product vector</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.op_MultiplyAssignment(Microsoft.Research.Liquid.CMat,System.Double)">
      <summary>
 Scales a matrix by a constant multiplier.
 The matrix is updated in place, rather than a new matrix being created.
 </summary>
      <param name="m1">The matrix to scale.</param>
      <param name="mul">The constant to multiply by.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.op_MultiplyBang(Microsoft.Research.Liquid.CMat,Microsoft.Research.Liquid.CMat)">
      <summary>
 Computes the Kronecker product of two matrices
 </summary>
      <param name="m1">The left matrix</param>
      <param name="m2">The right matrix</param>
      <returns>The result of the Kronecker product</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Power(System.Int32)">
      <summary>
 Computes an integer power of this matrix.
 NOTE: This destroys the contents of the current matrix.
 </summary>
      <param name="n">The power to raise this matrix to; must be greater than 0.</param>
      <returns>The resulting matrix</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Read(System.IO.BinaryReader)">
      <summary>
 Reads a matrix from a stream.
 </summary>
      <param name="br">A BinaryReader to deserialize a matrix from.</param>
      <returns>The new mnatrix</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.ToString">
      <summary>
 Gets a string representation of this matrix.
 Note that there is no limit on the size of the result; every row and column entry is included.
 </summary>
      <returns>The string representation</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.UnitaryError">
      <summary>
 Performs a rough check to see if this matrix is actually unitary.
 It calculates the biggest deviation from 1 of the diagonal elements
 of (this adj)*this.
 In other words, it calculates the largest deviation of the length of a row,
 viewed as a complex vector, from 1.
 The orthogonality of different rows is not checked.
 </summary>
      <returns>The worst deviation from 1.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CMat.Write(System.IO.BinaryWriter)">
      <summary>
 Writes this matrix to a stream for serialization.
 </summary>
      <param name="bw">A BinaryWriter to serialize this matrix to.</param>
    </member>
    <member name="T:Microsoft.Research.Liquid.Complex">
      <summary>Data type for complex numbers.</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.#ctor(System.Double,System.Double)">
      <summary>
 Constructs a complex number from its real and imaginary parts.
 </summary>
      <param name="r">Real value</param>
      <param name="i">Imaginary value</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.Conj">
      <summary>
 Computes the complex conjugate of this Complex number.
 </summary>
      <returns>The conjugate</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.Copy">
      <summary>
 Duplicates this Complex number in a new instance.
 </summary>
      <returns>The new Complex</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dumps this Complex number to the console and log with an optional indentation.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Complex.i">
      <summary>
 Gets the imaginary part of this Complex number.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Complex.I">
      <summary>
 The square root of negative one, as a Complex number.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Complex.MCC">
      <summary>
 Gets the squared magnitude of this Complex number.
 </summary>
      <returns>The squared magnitude (r*r+i*i)</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.Narrow">
      <summary>
 Converts this Complex number to a short human-readable string.
 </summary>
      <returns>The formatted string representation</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Complex.One">
      <summary>
 One, as a Complex number
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.op_Addition(Microsoft.Research.Liquid.Complex,Microsoft.Research.Liquid.Complex)">
      <summary>
 Adds two Complex numbers.
 </summary>
      <param name="a">The left-hand operand</param>
      <param name="b">The right-hand operand</param>
      <returns>NThe sum of the two operands</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.op_Multiply(Microsoft.Research.Liquid.Complex,Microsoft.Research.Liquid.Complex)">
      <summary>
 Multiplies two Complex numbers.
 </summary>
      <param name="a">Left hand operand.</param>
      <param name="b">Right hand operand.</param>
      <returns>The product of the two numbers</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.op_Multiply(Microsoft.Research.Liquid.Complex,System.Double)">
      <summary>
 Multiplies a Complex and a real number.
 </summary>
      <param name="a">The Complex number</param>
      <param name="b">The real number</param>
      <returns>The product of the two numbers</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.op_Multiply(System.Double,Microsoft.Research.Liquid.Complex)">
      <summary>
 Multiplies a real and a Complex number.
 </summary>
      <param name="a">The real number</param>
      <param name="b">The Complex number</param>
      <returns>The product of the two numbers</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.op_Subtraction(Microsoft.Research.Liquid.Complex,Microsoft.Research.Liquid.Complex)">
      <summary>
 Subtracts one Complex number from another.
 </summary>
      <param name="a">The left-hand operand</param>
      <param name="b">The right-hand operand</param>
      <returns>The difference of the two operands</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.op_TwiddleTwiddle(Microsoft.Research.Liquid.Complex)">
      <summary>
 Gets the complex conjugate of a Complex number.
 </summary>
      <param name="a">The Complex number to conjugate.</param>
      <returns>The conjugated Complex number</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.op_UnaryNegation(Microsoft.Research.Liquid.Complex)">
      <summary>
 Gets the negation of a Complex number.
 </summary>
      <param name="a">The Complex number to negate</param>
      <returns>The negated Complex number, (-r,-i)</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Complex.r">
      <summary>
 Gets the real part of this Complex number.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Complex.Tol">
      <summary>
 Tolerance for comparing two Complex numbers.
 This is used in various places in the system.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.ToString">
      <summary>
 Converts this Complex number to a human-readable string.
 </summary>
      <returns>The formatted string representation</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Complex.Wide">
      <summary>
 Converts this Complex number to a string suitable for input to other programs.
 </summary>
      <returns>The formatted string representation</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Complex.Zero">
      <summary>
 Zero, as a Complex number
 </summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.CSMat">
      <summary>
 A sparse matrix of complex numbers.
 <seealso cref="T::Microsoft.Research.Liquid.CMat" /></summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.#ctor(Microsoft.Research.Liquid.CMat,Microsoft.FSharp.Core.FSharpOption{System.Double})">
      <summary>
 Creates a sparse matrix from a dense matrix.
 </summary>
      <param name="m">The source matrix.</param>
      <param name="tol">An optional tolerance for identifying zero elements.
 The default is to use Complex.tol as the maximum magnitude to consider 0.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.#ctor(System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32,System.Double,System.Double}})">
      <summary>
 Creates a matrix from a list of elements.
 </summary>
      <param name="len">The dimension of the matrix; that is, the row or column count.</param>
      <param name="xyris">A list of elements. Each element should be a tuple in the form (row,col,real,imag).</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.#ctor(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Creates a new square identity or zero matrix.
 </summary>
      <param name="n">The dimension of the matrix; that is, the row or column count.</param>
      <param name="zero">An option to create a zero matrix rather than an identity matrix, if true.
 The default is false, which creates an identity matrix.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.Adj">
      <summary>
 Computes the adjoint (complex conjugate transpose) of this matrix.
 </summary>
      <returns>A new matrix that is the adjoint of this matrix</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.Clear">
      <summary>
 Clears out this matrix, setting all elements to zero.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.Copy">
      <summary>
 Makes a copy of this matrix.
 </summary>
      <returns>The new matrix</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.Dense(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Creates a dense matrix from this sparse matrix.
 </summary>
      <param name="zeros">Option to create a dense matrix the same size as this matrix
 but filled with zeroes, rather than copying this matrix. The default is to copy
 the entries of this matrix to the new dense matrix.</param>
      <returns>The new dense matrix</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dumps this matrix as a list of row-column indices and element complex values.
 Note that all non-zero elements are listed, so the output may be quite long.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.DumpDense(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dumps this sparse matrix in the same format as a dense matrix.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.DumpMCC(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dumps this matrix as a list of row-column indices and element squared magnitudes.
 Note that all non-zero elements are listed, so the output may be quite long.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.DumpML(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dumps this matrix in MatLab format.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
      <param name="nam">An optional name for the matrix. The default is A.</param>
      <param name="idxOffset">An optional number of rows and columns to skip.
 If this is not zero, then the square submatrix starting at this offset is dumped instead of the full matrix.
 The default is 0.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.Equals(Microsoft.Research.Liquid.CSMat,Microsoft.FSharp.Core.FSharpOption{System.Double})">
      <summary>
 Determines whether this matrix is equal to another.
 </summary>
      <param name="m2">The sparse matrix to compare to.</param>
      <param name="tol">An optional tolerance for considering real or imaginary parts equal.
 The default is Complex.Tol.</param>
      <returns>true if the matrices are equal, within the tolerance limit, or 
 false otherwise.</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.CSMat.Item(System.Int32,System.Int32)">
      <summary>
 Gets an element of the matrix.
 </summary>
      <param name="x">The row index of the desired element.</param>
      <param name="y">The column index of the desired element.</param>
      <returns>The matrix element, as a Complex number</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.Kron(Microsoft.Research.Liquid.CSMat)">
      <summary>
 Computes the Kronecker Product of this matrix with another matrix.
 </summary>
      <param name="m2">The right-hand side matrix in the Kronecker product.</param>
      <returns>The result of the Kronecker product</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.Kron(System.Int32)">
      <summary>
 Computes the Kronecker Product of this matrix with an identity matrix.
 The identity matrix is on the right-hand side of the product.
 </summary>
      <param name="lenI">The dimension of the identity matrix (N of NxN).</param>
      <returns>The result of the Kronecker product</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.CSMat.Length">
      <summary>
 The dimension of this matrix; that is, the number of rows or columns.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.Mul(Microsoft.Research.Liquid.CSMat)">
      <summary>
 Computes the product of this matrix and another matrix.
 Highly efficient.
 </summary>
      <param name="m2">The right-hand matrix to be multiplied by this matrix.</param>
      <returns>New resulting sparse matrix</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.Mul(Microsoft.Research.Liquid.CVec)">
      <summary>
 Computes the product of this matric and a vector.
 </summary>
      <param name="v">The vector to multiply.</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.op_Multiply(Microsoft.Research.Liquid.CSMat,Microsoft.Research.Liquid.CSMat)">
      <summary>
 Computes the product of two matrices.
 Highly efficient.
 </summary>
      <param name="m1">The left-hand matrix.</param>
      <param name="m2">THe right-hand matrix.</param>
      <returns>The resulting product matrix</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.op_Multiply(Microsoft.Research.Liquid.CSMat,Microsoft.Research.Liquid.CVec)">
      <summary>
 Computes the product of a matrix and a vector.
 </summary>
      <param name="m">The matrix</param>
      <param name="v">The vector</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.op_MultiplyBang(Microsoft.Research.Liquid.CSMat,Microsoft.Research.Liquid.CSMat)">
      <summary>
 Computes the Kronecker product of two matrices
 </summary>
      <param name="m1">The left matrix</param>
      <param name="m2">The right matrix</param>
      <returns>The result of the Kronecker product</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.Read(System.IO.BinaryReader)">
      <summary>
 Reads a matrix from a stream.
 The matrix must originally have been written using the 
 <see cref="M:Microsoft.Research.Liquid.CSMat.Write(System.IO.BinaryWriter)">Write</see> method.
 </summary>
      <param name="br">The stream to read the data from.</param>
      <returns>The read-in matrix</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.ToString">
      <summary>
 Gets a string representation of this matrix.
 Note that all non-zero elements are listed, so this string may be quite long.
 </summary>
      <returns>The string representation</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.UnitaryError">
      <summary>
 Performs a rough check to see if this matrix is actually unitary.
 It calculates the biggest deviation from 1 of the diagonal elements
 of (this adj)*this.
 In other words, it calculates the largest deviation of the length of a row,
 viewed as a complex vector, from 1.
 The orthogonality of different rows is not checked.
 </summary>
      <returns>The worst deviation from 1.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CSMat.Write(System.IO.BinaryWriter)">
      <summary>
 Writes this matrix to a stream.
 The matrix may be recreated by using the 
 <see cref="M:Microsoft.Research.Liquid.CSMat.Read(System.IO.BinaryReader)">Read</see> method.
 </summary>
      <param name="bw">The stream to serialize this matrix to</param>
    </member>
    <member name="T:Microsoft.Research.Liquid.CVec">
      <summary>
 A block-sparse vector of complex numbers.
</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.#ctor(System.Double[],Microsoft.FSharp.Core.FSharpOption{System.Double[]},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Creates a new  vector from initial value vectors, real and imaginary.
 Note that the length of the new vector must be no more than 2^20.
 </summary>
      <param name="rs">The vector of real initial values</param>
      <param name="is">An optional vector of imaginary initial values; default is zero</param>
      <param name="force">Option to force complete (non-sparse) allocation of 
 the vector; defaults to false</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.#ctor(System.UInt64,Microsoft.FSharp.Core.FSharpOption{System.Double[]},Microsoft.FSharp.Core.FSharpOption{System.Double[]},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Creates a new  vector.
 By default, the vector is all zero.
 Optionally, the real and impaginary initial values may be provided;
 in this case, the vector must be no more than 2^20 in length.
 </summary>
      <param name="_len">The length of the vector</param>
      <param name="rsInit">Optional real parts of the initial values; if provided, there
 must be an entry for each element in the vector. Default is zero.</param>
      <param name="isInit">Optional imaginary of the initial values; if provided, there
 must be an entry for each element in the vector. Default is zero.</param>
      <param name="forceAlloc">Option to force complete (non-sparse) allocation of 
 the vector; defaults to false</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.#ctor(System.UInt64,System.Boolean)">
      <summary>
 Creates a new vector filled with zeroes.
 </summary>
      <param name="_len">The length of the vector</param>
      <param name="force">Option to force complete (non-sparse) allocation of 
 the vector. The default to false, which leaves the vector sparse.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.AddMCC">
      <summary>
 Calculates the norm of this vector.
 The norm is the square root of the sum of the complex magnitudes of the vector elements.
 </summary>
      <returns>This vector's norm</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.Copy">
      <summary>
 Creates an exact copy of this vector.
 </summary>
      <returns>The new vector</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dumps this vector using the provided function.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
      <param name="maxNZ">The optional maximum number of  non-zeros to dump. The default is 256</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.DumpMCC(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dump vector MCC with provided function
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
      <param name="thresh">Output threshold (optional=tol*1.e+2)</param>
      <param name="both">Output complex value as well (optional=false)</param>
      <param name="maxNZ">Max non-zeros to dump (optional=256)</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.GlobalPhase">
      <summary>
 Estimates the global phase of a vector that represents a quantum state.
 The estimate is computed as the complex phase of the vector element with
 the greatest amplitude.
 </summary>
      <returns>A tuple whose first element is the estimated phase angle, in radians,
 and whose second element is the unit-magnitude Complex number with the 
 opposite phase.</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.CVec.iSafe(System.UInt64)">
      <summary>
 Gets the imaginary part of an element of this vector by index.
 </summary>
      <param name="i">The index of the element to get</param>
      <returns>The imaginary part of the Complex value of the element</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.Kron(Microsoft.Research.Liquid.CVec)">
      <summary>
 Computes the Kronecker product of this vector and another.
 </summary>
      <param name="v2">Vector to multiply this one by</param>
      <returns>The result vector</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.CVec.Length">
      <summary>
 The length of this vector
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.Normalize(Microsoft.FSharp.Core.FSharpOption{System.Double})">
      <summary>
 Normalizes this vector to length 1.0.
 </summary>
      <param name="len">The optional current length, if already calculated.
 The default is to invoke and use the result of 
 <see cref="M:Microsoft.Research.Liquid.CVec.AddMCC">AddMCC</see></param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.op_MultiplyBang(Microsoft.Research.Liquid.CVec,Microsoft.Research.Liquid.CVec)">
      <summary>
 Computes the Kronecker product of two vectors.
 </summary>
      <param name="v1">Left vector</param>
      <param name="v2">Right vector</param>
      <returns>The result vector</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.Read(System.IO.BinaryReader)">
      <summary>
 Reads a new vector from a binary file.
 Note that this routine is only intended to read vectors written with the
 <see cref="M:Microsoft.Research.Liquid.CVec.Write(System.IO.BinaryWriter)">Write</see> method.
 <seealso cref="M:Microsoft.Research.Liquid.CVec.Write(System.IO.BinaryWriter)" /></summary>
      <param name="br">The BinaryReader from which the vector should be read.</param>
      <returns>The new vector</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.CVec.rSafe(System.UInt64)">
      <summary>
 Gets the real part of an element of this vector by index.
 </summary>
      <param name="i">The index of the element to get</param>
      <returns>The real part of the Complex value of the element</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.CVec.Safe(System.UInt64)">
      <summary>
 Gets an element of this vector by index.
 </summary>
      <param name="i">The index of the element to get</param>
      <returns>The Complex value of the element</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.Scale(Microsoft.Research.Liquid.Complex)">
      <summary>
 Scale all elements of the vector (unsafe)
 </summary>
      <param name="scale">Complex scale factor</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.ToString">
      <summary>
 Converts this vector to a string.
 At most the first 512 entries are displayed.
 </summary>
      <returns>The string</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.Write(System.IO.BinaryWriter)">
      <summary>
 Writes this vector to a binary file.
 <seealso cref="M:Microsoft.Research.Liquid.CVec.Read(System.IO.BinaryReader)" /></summary>
      <param name="bw">The BinaryWriter that this vector should be written to.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.CVec.Zero">
      <summary>
 Zeroes this vector.
 Note that this also densely fills in the vector.
 </summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.Fermion">
      <summary>
 Hamiltonian simulation for fermionic systems.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Fermion.#ctor(System.Double,System.Double,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32,System.Double}},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32,System.Int32,System.Int32,System.Double}},System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Int32}})">
      <summary>
 Creates a new Fermion instance from orbit overlap integrals.
 </summary>
      <param name="eMin">The minimum energy to use for phase estimation.</param>
      <param name="eMax">The maximum energy to use for phase estimation.</param>
      <param name="trotterN">The Trotter number to use</param>
      <param name="bits">The number of bits of phase estimation accuracy desired.</param>
      <param name="order">The Trotter order, either 1 or 2 (first or second order).</param>
      <param name="ij">A list of tuples for single-body orbital constants.
 Each tuple represents an Hpq term, and contains p, q, and the value of Hpq.
 Note that pp terms are included in this category.</param>
      <param name="ijkl">A list of tuples for two-body orbital constants.
 Each tuple represents an Hpqrs term, and contains p, q, r, s, and the value of Hpqrs.
 Note that pqqp and pqqr terms are included in this category.</param>
      <param name="dic">A dictionary of options. See the Remarks for details.</param>
      <param name="preps">An optional specification of a 1-based electron prep list, for diagonal fix-up.
 The default is no prep and no fix-up.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Fermion.#ctor(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit}})">
      <summary>
 Creates a new Fermion instance from a prebuilt Circuit.
 </summary>
      <param name="eMin">The minimum energy to use for phase estimation.</param>
      <param name="eMax">The maximum energy to use for phase estimation.</param>
      <param name="trotterN">The Trotter number to use</param>
      <param name="bits">The number of bits of phase estimation accuracy desired.</param>
      <param name="order">The Trotter order, either 1 or 2 (first or second order).</param>
      <param name="dic">A dictionary of options. See the Remarks for details.</param>
      <param name="Ua">A gate, usually a wrapped Circuit, that implements the Hamiltonian.
 The gate's parameter is the time step to evolve by.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Fermion.bits">
      <summary>
 The mumber of phase estimation bits. 
 This is the bit precision plus two.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Fermion.Build(Microsoft.Research.Liquid.GrowPars)">
      <summary>
 Builds either a grown circuit or an exponentiated unitary.
 </summary>
      <param name="gp">Grow parameters for 
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">Circuit.GrowGates</see>.
 If the <see cref="P:Microsoft.Research.Liquid.GrowPars.Single">Single</see>
 flag is set to true, then a single exponentiated unitary is built.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Fermion.Circs">
      <summary>
 The built circuits, in bit order.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Fermion.Clean">
      <summary>
 Cleans out temporary files.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Fermion.currentCirc">
      <summary>
 The last circuit that was run (ungrown).
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Fermion.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dumps out information on this simulator.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Fermion.eMax">
      <summary>
 The maximum energy for phase estimation.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Fermion.eMin">
      <summary>
 The minimum energy for phase estimation.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Fermion.Energy">
      <summary>
 The result of phase estimation, interpreted as an energy.
 This will always be between eMin and eMax.
 This value is only available after 
 <see cref="M:Microsoft.Research.Liquid.Fermion.Run(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Int32})">Run</see> has been called.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Fermion.Load(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
      <summary>
 Loads a Fermion test from a .dat file based on a script.
 </summary>
      <param name="dic">A dictionary of options. See the Remarks for details.</param>
      <param name="dataFile">A relative or full path to the .dat file to load.</param>
      <returns>A single, multi-line string containing orbital information for the test number
 specified in the option dictionary.
 This string is suitable for passing (as the only element of an array) to 
 <see cref="M:Microsoft.Research.Liquid.Fermion.LoadOrbs(System.Collections.Generic.Dictionary{System.String,System.String},System.String[])">LoadOrbs</see>.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Fermion.LoadOrbs(System.Collections.Generic.Dictionary{System.String,System.String},System.String[])">
      <summary>
 Loads orbital information from an array of strings.
 </summary>
      <param name="dic">A dictionary of options. See the Remarks for details.</param>
      <param name="data">An array of formatted strings containing orbital information.
 Each string corresponds to a single line in a .dat file.
 The string format is described in the Users Manual.</param>
      <returns>
 A tuple containing the single-orbital terms; the two-orbital terms;
 an informational string; and the nuclear energy.
 The orbital terms are in the proper format to pass to the Fermion constructor.
 </returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Fermion.omega">
      <summary>
 The energy range, eMax - eMin, for phase estimation.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Fermion.order">
      <summary>
 The trotter order for phase estimation.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Fermion.Phase">
      <summary>
 The result of phase estimation, as an angle between 0 and 2*pi.
 This value is only available after 
 <see cref="M:Microsoft.Research.Liquid.Fermion.Run(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Int32})">Run</see> has been called.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Fermion.PhaseSetup(System.Int32,System.Double,System.String)">
      <summary>
 Sets up phase estimation for all runs.
 </summary>
      <param name="bits">The number of bits of phase estimation accuracy desired.</param>
      <param name="alterNoise">Magnitude of random (additive) noise to apply to evolution angles.
 Set this to 0.0 for no noise.</param>
      <param name="peType">The type of phase estimation to perform.
 Possible values are:
 <ul><li><b>"circ"</b>: Basic PE on the full circuit</li><li><b>"expon"</b>: Create matrix exponentiations</li><li><b>"noise"</b>: Compute noise while running (uses a single Unitary)</li><li><b>"file"</b>: Serialize matrix exponentation to disk</li><li><b>"atan"</b>: Use arc tangent to go forward and do classical post processing</li><li><b>"default"</b>: Use type that naturally goes with specified GrowPars</li></ul></param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Fermion.Prep(Microsoft.FSharp.Collections.FSharpList{System.Int32})">
      <summary>
 Prepares an initial state from the provided spin orbital indices.
 </summary>
      <param name="prep">The list of spin orbitals to mark as occupied.</param>
      <returns>The "prep state" with exactly the listed orbitals occupied.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Fermion.Run(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Runs the simulation to obtain a phase estimate. 
 A previous call to Build() or BuildSingle() is required.
 </summary>
      <param name="single">Whether or not this Hamiltonian is built into a single Unitary.</param>
      <param name="maxTries">An optional maximum number of measurements to take.
 The default is 40.</param>
      <returns>None if it succeeded, or Some (int bit position) if it failed.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Fermion.Run(System.Collections.Generic.Dictionary{System.String,System.String},Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit}},Microsoft.Research.Liquid.Ket)">
      <summary>
 Runs a Fermion test from a pre-built circuit and state vector.
 See the Users Manual for details on the parameters.
 </summary>
      <param name="dic">A dictionary of options. See the Remarks for details.</param>
      <param name="Ua">A gate, usually a wrapped Circuit, that implements the Hamiltonian.
 The gate's parameter is the time step to evolve by.</param>
      <param name="ket">The state vector to use as the initial state.</param>
      <returns>A tuple of the phase estimation error bit, which will be -1 if no error occured,
 and the Fermion instance that was run.
 The <see cref="P:Microsoft.Research.Liquid.Fermion.Phase">Phase</see> and 
 <see cref="P:Microsoft.Research.Liquid.Fermion.Energy">Energy</see> properties 
 of the Fermion instance may be read to get the phase estimation results.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Fermion.Run(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
      <summary>
 Runs a Fermion test from a .dat file, based on a script
 A basic axecution trace is sent to both the console and the log.
 Detailed information is sent just sent to the log.
 See the Users Manual for details on the parameters.
 </summary>
      <param name="dic">A dictionary of options. See the Remarks for details.</param>
      <param name="dataFile">A relative or full path to the .dat file to load.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Fermion.Run(System.Collections.Generic.Dictionary{System.String,System.String},System.String[])">
      <summary>
 Runs a pre-loaded Fermion test based on a script.
 A basic axecution trace is sent to both the console and the log.
 Detailed information is sent just sent to the log.
 See the Users Manual for details on the parameters.
 </summary>
      <param name="dic">A dictionary of options. See the Remarks for details.</param>
      <param name="data">An array of formatted strings containing orbital information.
 Each string corresponds to a single line in a .dat file.
 The string format is described in the Users Manual.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Fermion.trotterN">
      <summary>
 The trotter number for phase estimation.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Fermion.tTotal">
      <summary>
 The total evolution time for phase estimation. This is equal to 2*p1/omega.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Fermion.Ua">
      <summary>
 The gate function that implements a full Hamiltonian time step
</summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.Gate">
      <summary>
 A quantum gate.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Gate.#ctor(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.CSMat},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GateOp},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.Gate}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{System.Object}})">
      <summary>
 Creates a new gate from scratch.
 </summary>
      <param name="Name">The optional name of the gate we're creating.
 The default is "".</param>
      <param name="Qubits">The optional arity of gate; that is, the number of qubits this gate operates on. 
 If a matrix for the gate is provided using the Mat parameter, then the arity is deduced from the
 dimensions of the matrix.
 The default value is 0.
 </param>
      <param name="Mat">An optional sparse unitary matrix that implements the gate.
 This parameter is only used for gates that implement a unitary operation.
 The default is no unitary.</param>
      <param name="Draw">An optional string to use to render the gate.
 This should be a <see href="http://physics.unm.edu/CQuIC//Qcircuit/">Q-Circuit</see>
 drawing string, if provided.
 The default is "", which means that the gate doesn't show up when rendered.</param>
      <param name="Help">An optional help string for the gate.
 The default is no help string, "".</param>
      <param name="Op">The optional gate operation to perform.
 The default is Normal, which is a unitary gate defined by a matrix.</param>
      <param name="Parent">The optional parent gate, if required by the gate operation type.
 The default is None.</param>
      <param name="User">An optional user-defined field.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Gate.AddControl(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Creates a new gate by adding one or more control qubits to an existing unitary gate.
 </summary>
      <param name="count">The optional number of control qubits to add.
 The default is a single control.</param>
      <param name="noCache">An option to prevent caching of the new gate.
 The default is false, which means that the new gate should be cached.
 The key for the cache is a sequence of capital Cs, one for each control
 qubit added, followed by an underscore, '_', and then the name of the base gate.</param>
      <returns>The new controlled gate</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Gate.Arity">
      <summary>
 The arity of the gate.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Gate.Build(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.Research.Liquid.Gate})">
      <summary>
 Gets the definition of a gate, using the cache.
 If the gate is already in the cache, the cached definition is returned.
 Otherwise, a new gate will be created, added to the cache, and returned.
 </summary>
      <param name="key">The uniqur key to use to identify this gate in the cache.
 This may be more than just the gate name; for instance, for a rotation gate,
 the cache key must include the rotation angle as well as just "Rz".
 If the key is null or "", the cache will be bypassed.</param>
      <param name="gen">A function that may be used to create a definition for the
 gate if it is not already in the cache.</param>
      <returns>The gate associated with the provided key</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Gate.CacheClear">
      <summary>
 Clears out the gate cache.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Gate.CacheDisable">
      <summary>
 Whether or not the gate cache is disabled.
 The cache is used if this property is false.
 The cache should be disabled if gates are being built in parallel.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Gate.CacheStats">
      <summary>
 Gets gate cache statistics.
 </summary>
      <returns>A tuple of the cache hit count and cache miss count.</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Gate.Draw">
      <summary>
 The drawing instructions for this gate.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Gate.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dumps the full gate information to the consol and/or log.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Gate.Help">
      <summary>
 The help string for this gate.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Gate.Mat">
      <summary>
 The unitary matrix for this gate.
 If the gate is not defined by a unitary, this will be a 0x0 matrix.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Gate.Name">
      <summary>
 The name of this gate.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Gate.NewMat(Microsoft.Research.Liquid.CSMat)">
      <summary>
 Makes a new gate based on this gate but with new unitary matrix.
 </summary>
      <param name="mat">The unitary matrix for the new gate.</param>
      <returns>The new gate</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Gate.Op">
      <summary>
 This gate's operation.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Gate.Parent">
      <summary>
 This gate's parent, if any. 
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Gate.Qubits">
      <summary>
 The arity of this gate; that is, the number of qubits the gate operates on.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Gate.Run(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Run this gate.
 The details depend on the current value of 
 <see cref="P:Microsoft.Research.Liquid.Ket.Mode(Microsoft.Research.Liquid.KetMode)">Ket.Mode</see>:
 <ul><li><b>RunMode</b>: Apply this gate operation to the supplied qubits.</li><li><b>GateMode</b>: Stores this gate definition into the current Ket.
 This is for internal use.</li><li><b>CircMode</b>: Compiles this gate into a Circuit.
 This is for internal use.</li></ul></summary>
      <param name="qs">The Qubits for this gate to operate on.
 They are also used to identify the current Ket.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Gate.ShowMem(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Circuit}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Outputs memory and garbage collection statistics to the log and console.
 </summary>
      <param name="seconds">A minimum interval between reports.
 If a report was displayed within more recently, then no new report is displayed.</param>
      <param name="f">A function that returns a string to output as a prefix to the report.</param>
      <param name="cs">An optional list of Circuits to analyze.
 The count of Circuits in the list is reported.
 If the "deep" parameter is true, then the total count of gates in these Circuits is also reported.
 The default is an empty list, which displays counts of 0.</param>
      <param name="deep">An option indicating whether or not to count the gates in the list of Circuits.
 The default is false, which indicates that the gates should not be counted and will be reported as 0.</param>
      <param name="collect">An option indicating whether to force a garbage collection.
 The default is false, to not force a collection.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Gate.ShowMem(System.Int32,System.String,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Circuit}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Outputs memory and garbage collection statistics to the log and console.
 </summary>
      <param name="seconds">A minimum interval between reports.
 If a report was displayed within more recently, then no new report is displayed.</param>
      <param name="str">A string to output as a prefix to the report.</param>
      <param name="cs">An optional list of Circuits to analyze.
 The count of Circuits in the list is reported.
 If the "deep" parameter is true, then the total count of gates in these Circuits is also reported.
 The default is an empty list, which displays counts of 0.</param>
      <param name="deep">An option indicating whether or not to count the gates in the list of Circuits.
 The default is false, which indicates that the gates should not be counted and will be reported as 0.</param>
      <param name="collect">An option indicating whether to force a garbage collection.
 The default is false, to not force a collection.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Gate.ToString">
      <summary>
 Returns a string representation of this gate, based on the gate's name,
 help string, and type.
 </summary>
      <returns>The string representation</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Gate.User">
      <summary>
 The user info associated with this gate, if any.
 </summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.GateOp">
      <summary>
 Gate operation type.
 This is used in <see cref="T:Microsoft.Research.Liquid.Gate">Gate</see> definitions.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.GateOp.ToString">
      <summary>
 Creates a string representation of this gate operation type.
 </summary>
      <returns>The string</returns>
    </member>
    <member name="T:Microsoft.Research.Liquid.GrowPars">
      <summary>
 Parameters that control circuit growth.
 See <see cref="M:Microsoft.Research.Liquid.Circuit.Grow(Microsoft.Research.Liquid.Ket,Microsoft.Research.Liquid.GrowPars)">Circuit.Grow</see>,
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">Circuit.GrowGates</see>,
 and <see cref="M:Microsoft.Research.Liquid.Circuit.GrowSingle(Microsoft.Research.Liquid.GrowPars)">Circuit.GrowSingle</see>.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.GrowPars.#ctor(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Creates an instance with appropriate parameters for 
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">Circuit.GrowGates</see>,
 which generates a denser circuit equivalent to an existing Circuit.
 </summary>
      <param name="maxWires">An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.MaxWires">MaxWires</see>.
 The default is 11.</param>
      <param name="verbose">An optional value for
 <see cref="P:Microsoft.Research.Liquid.GrowPars.Verbosity">Verbosity</see>. 
 The default is 0.</param>
      <param name="allowDense">An optional value for
 <see cref="P:Microsoft.Research.Liquid.GrowPars.AllowDense">AllowDense</see>. 
 The default is false.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.GrowPars.#ctor(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.Double,System.Boolean}})">
      <summary>
 Creates an instance with appropriate parameters for 
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowSingle(Microsoft.Research.Liquid.GrowPars)">Circuit.GrowSingle</see>,
 which generates a single unitary operation equivalent to an existing Circuit.
 </summary>
      <param name="half">
 The value for <see cref="P:Microsoft.Research.Liquid.GrowPars.Half">Half</see>.
 This parameter is required.
 </param>
      <param name="eCnt">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.ECnt">ECnt</see>.
 The default is 0.
 </param>
      <param name="oCnt">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.OCnt">OCnt</see>.
 The default is 0.
 </param>
      <param name="skip">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.Skip">Skip</see>.
 The default is 0.
 </param>
      <param name="diff">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.ECnt">ECnt</see>.
 The default is an empty list, [].
 </param>
      <param name="verbose">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.Verbose">Verbose</see>.
 The default is 1.
 </param>
      <param name="parity">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.Parity">Parity</see>.
 The default is false.
 </param>
      <param name="redund">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.Redund">Redund</see>.
 The default is 0.
 </param>
      <param name="coalesce">
 An optional value for <see cref="P:Microsoft.Research.Liquid.GrowPars.Coalesce">Coalesce</see>.
 The default is (0.0, false).
 </param>
    </member>
    <member name="P:Microsoft.Research.Liquid.GrowPars.AllowDense">
      <summary>
 If true, allow dense matrices to be generated by
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">Circuit.GrowGates</see>.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.GrowPars.Coalesce">
      <summary>
 For Hamiltonian circuits, a tuple of a scale value and 
 a flag specifying whether or not to keep rotation gates around small angles.
 The scale value is used if the flag is false.
 See the Users' Guide for details.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.GrowPars.Diff">
      <summary>
 For Fermion circuits, a list of allowed differences between spin-up and spin-down counts.
 Effectively, this list constrains the possible values of the total net spin of valid configurations.
 An empty list, [], means to allow any difference.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.GrowPars.ECnt">
      <summary>
 For Fermion circuits, the valid total electron count (total number of occupied states).
 A value of 0 means that any number of electrons is valid.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.GrowPars.Half">
      <summary>
 For Fermion circuits, are the qubits ordered so that the first half are the spin-up states?
 The alternative is for qubits to represent alternating spin-up andn spin-down states.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.GrowPars.MaxWires">
      <summary>
 The maximum wire count for a single grown gate generated by 
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowGates(Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">Circuit.GrowGates</see></summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.GrowPars.OCnt">
      <summary>
 For Fermion circuits, the number of electron states. 
 In chemical simulations, this is the spin orbital count.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.GrowPars.Parity">
      <summary>
 For Fermion circuits, whether to enforce conservation of angular momentum via parity.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.GrowPars.Redund">
      <summary>
 For Fermion circuits, whether to ignore (set to zero) portions of the resulting unitary
 that don't satisfy the <see cref="P:Microsoft.Research.Liquid.GrowPars.ECnt">electron count</see>, 
 <see cref="P:Microsoft.Research.Liquid.GrowPars.Parity">parity check</see>, or 
 <see cref="P:Microsoft.Research.Liquid.GrowPars.Diff">net spin</see> constraints.
 See the Users' Guide for details.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.GrowPars.Single">
      <summary>
 If true, build a single unitary; if false, grow gates into a denser circuit.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.GrowPars.Skip">
      <summary>
 Count of initial qubits to skip (because they are used for phase estimation) in 
 <see cref="M:Microsoft.Research.Liquid.Circuit.GrowSingle(Microsoft.Research.Liquid.GrowPars)">Circuit.GrowSingle</see>.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.GrowPars.ToString">
      <summary>
 Gets a string representation of this circuit grow parameter set.
 </summary>
      <returns>The string</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.GrowPars.Verbose">
      <summary>
 The logging verbosity level.
 Possible values are:
 <ul><li><b>0</b>: No grow logging</li><li><b>1</b>: Final circuit logging</li><li><b>2</b>: Full detailed logging</li></ul></summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.GrowPars.VerboseSet(System.Int32)">
      <summary>
 Creates a new GrowPars with a different verbosity setting.
 <sealso cref="P:Microsoft.Research.Liquid.GrowPars.Verbosity" /></summary>
      <param name="vNew">The new verbosity level</param>
      <returns>The new GrowPars instance</returns>
    </member>
    <member name="T:Microsoft.Research.Liquid.Hamiltonian">
      <summary>
 Base class for Hamiltonian dynamics simulators.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Hamiltonian.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Microsoft.Research.Liquid.Hamiltonian</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Hamiltonian.decohereModel">
      <summary>
 The decoherence model for this Hamiltonian.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Hamiltonian.Ket">
      <summary>Gets the Ket vector associated with this Hamiltonian</summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.HamiltonianGates">
      <summary>A collection of gates that are useful for Hamiltonian simulation and annealing.</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.CGtheta(System.Double,System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a controlled global phase rotation.
 </summary>
      <param name="theta">The rotation angle. 2*pi is a full rotation.</param>
      <param name="factor">A multiplier, used to compute the gate label.</param>
      <param name="qs">The first qubit in the list is the control; 
 the second qubit is the target.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.CRx(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Controlled Pauli X rotation.
 </summary>
      <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
      <param name="factor">A multiplier, used to compute the gate label.</param>
      <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
      <param name="qs">The first qubit in the list is the control; 
 the second qubit is the target.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.CRy(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Controlled Pauli Y rotation.
 </summary>
      <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
      <param name="factor">A multiplier, used to compute the gate label.</param>
      <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
      <param name="qs">The first qubit in the list is the control; 
 the second qubit is the target.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.CRz(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Controlled Pauli Z rotation.
 </summary>
      <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
      <param name="factor">A multiplier, used to compute the gate label.</param>
      <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
      <param name="qs">The first qubit in the list is the control; 
 the second qubit is the target.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.CTtheta(System.Double,System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a controlled T rotation.
 </summary>
      <param name="theta">The rotation angle. 2*pi is a full rotation.</param>
      <param name="factor">A multiplier, used to compute the gate label.</param>
      <param name="qs">The first qubit in the list is the control; 
 the second qubit is the target.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.Entangle(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32}},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Entangles a list of qubits.
 This is useful for building Jordan-Wigner strings.
 </summary>
      <param name="ladder">A list of pairs of qubit indices to entangle.
 Each entry should have a tuple of two indices that refer to qubits in the
 <paramref name="qs" /> list.
 The entangle gate will wrap a sequence of CNOT gates, one for each tuple,
 each with the control being the first qubit in the tuple and 
 the target being the second in the tuple.
 The CNOT gates are built in ladder list order.</param>
      <param name="qs">The qubits to build the ladder from.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.Gtheta(System.Double,System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a global phase rotation.
 This is functionally equivalent to <c>Rpauli (2.0*theta) I qs</c>, 
 but has some additional drawing options.
 </summary>
      <param name="theta">The rotation angle. 2*pi is a full rotation.</param>
      <param name="factor">A multiplier, used to compute the gate label.</param>
      <param name="qs">The first qubit in the list is rotated.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.LoadCache">
      <summary>Preload the cache with the ZZ, Ybasis, and YbasisAdj gates.</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.Rpauli(System.Double,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs an arbitrary rotation based on an existing gate.
 The base gate may be any unitary gate with a Hermitian, idempotent matrix.
 Of course, all Pauli gates satisfy this criteria.
 </summary>
      <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
      <param name="f">The gate to base the rotation on.</param>
      <param name="qs">The first qubit in the list is rotated.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.Rx(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Pauli X rotation.
 This is functionally equivalent to <c>Rpauli theta X qs</c>, 
 but has some additional drawing options.
 </summary>
      <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
      <param name="factor">A multiplier, used to compute the gate label.</param>
      <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
      <param name="qs">The first qubit in the list is rotated.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.Ry(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Pauli Y rotation.
 This is functionally equivalent to <c>Rpauli theta Y qs</c>, 
 but has some additional drawing options.
 </summary>
      <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
      <param name="factor">A multiplier, used to compute the gate label.</param>
      <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
      <param name="qs">The first qubit in the list is rotated.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.Rz(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Pauli Z rotation.
 This is functionally equivalent to <c>Rpauli theta Z qs</c>, 
 but has some additional drawing options.
 </summary>
      <param name="theta">The rotation angle. 4*pi is a full rotation.</param>
      <param name="factor">A multiplier, used to compute the gate label.</param>
      <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
      <param name="qs">The first qubit in the list is rotated.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.Ttheta(System.Double,System.Double,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a phase gate rotation.
 This is functionally equivalent to <c>Rpauli (2.0*theta) T qs</c>, 
 but has some additional drawing options.
 </summary>
      <param name="theta">The rotation angle. 2*pi is a full rotation.</param>
      <param name="factor">A multiplier, used to compute the gate label.</param>
      <param name="subs">A subscript to attach to the gate label.
 Use an empty string, "", if no subscript is desired.</param>
      <param name="qs">The first qubit in the list is rotated.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.UnEntangle(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Int32}},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Unentangles a list of qubits.
 This is useful for building Jordan-Wigner strings.
 </summary>
      <param name="ladder">A list of pairs of qubit indices to entangle.
 Each entry should have a tuple of two indices that refer to qubits in the
 <paramref name="qs" /> list.
 The entangle gate will wrap a sequence of CNOT gates, one for each tuple,
 each with the control being the first qubit in the tuple and 
 the target being the second in the tuple.
 The CNOT gates are built in the reverse order of the ladder list.</param>
      <param name="qs">The qubits to build the ladder from.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.Ybasis(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a basis change from Z to Y.
 </summary>
      <param name="qs">The first qubit in the list has its basis changed.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.YbasisAdj(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a basis change from Y to Z.
 This is the adjoint of 
 <see cref="M:Microsoft.Research.Liquid.HamiltonianGates.Ybasis(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">Ybasis</see>.
 </summary>
      <param name="qs">The first qubit in the list has its basis changed.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.ZR(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Pauli Z rotation. This is equivalent to <c>Rpauli (2.0*theta) Z qs</c>.
 </summary>
      <param name="theta">The rotation angle. 2*pi is a full rotation.</param>
      <param name="qs">The first qubit in the list is rotated.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.ZZ(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a ZZ gate: Pauli Zs on consectutive wires.
 This is used for coupling strength.
 </summary>
      <param name="qs">The first two qubits will have Z performed on them.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.HamiltonianGates.ZZR(System.Double,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Pauli ZZ rotation; that is, a simultaneous Z rotation of two qubits.
 This is equivalent to <c>Rpauli (2.0*theta) ZZ qs</c>.
 </summary>
      <param name="theta">The rotation angle. 2*pi is a full rotation.</param>
      <param name="qs">The first two qubits in the list are rotated.</param>
    </member>
    <member name="T:Microsoft.Research.Liquid.Ket">
      <summary>
 Represents a state vector.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.#ctor">
      <summary>
 Creates an empty Ket vector.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.#ctor(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.Bit})">
      <summary>
 Creates a populated Ket vector.
 </summary>
      <param name="count">Number of qubits to allocate.</param>
      <param name="init">An optional initial value for the qubits, either Zero or One.
 The default is to initialize all qubits to Zero.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Add(Microsoft.Research.Liquid.Bit)">
      <summary>
 Adds a new qubit to the state with a classical Bit value.
 The new qubit is unentangled and has the provided state.
 Note that the new qubit is not considered measured.
 </summary>
      <param name="b">The initial state of the added qubit.</param>
      <returns>The new Qubit</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Add(Microsoft.Research.Liquid.CVec)">
      <summary>
 Adds a new qubit to the state with a complex state vector.
 The new qubit is unentangled and has the provided state.
 </summary>
      <param name="cv">The state of the added qubit.</param>
      <returns>The new Qubit</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Add(System.Int32,Microsoft.Research.Liquid.Bit)">
      <summary>
 Adds multiple qubits to the state, all with the same classical Bit value.
 The new qubits are unentangled and have the provided state.
 Note that the new qubits are not considered measured.
 </summary>
      <param name="cnt">The number of qubits to add.</param>
      <param name="b">The initial state of the added qubits.</param>
      <returns>The new Qubits</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Copy">
      <summary>
 Makes a new Ket that is a deep copy of this Ket.
 </summary>
      <returns>The new ket vector</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Ket.Count">
      <summary>
 Count of Qubits in state
</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Decohere(Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Qubit,System.Boolean})">
      <summary>
 Applies a function to each Qubit in the state vector, returning the list of
 qubit IDs for which the function returned true.
 This method is usually used to apply noise to the state.
 </summary>
      <param name="decohere">The function to apply to each qubit.
 This function is allowed to modify the state of the qubit.</param>
      <returns>The list of qubits where the function returned true</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Dump this state vector.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
      <param name="doMCC">An option that, if true, causes probabilities (complex magnitude squared) to be output
 for each state entry, rather than the complex amplitude.
 The default is to output the complex amplitude for each state.</param>
      <param name="doSort">An option that, if true, causes the output to be sorted in qubit ID order.
 The default is to sort the output.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.DumpKP(Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Dump the portion of this state vector that includes a specific qubit and 
 all of the qubits it is entangled with.
 If this Ket is a product state, then only the factor containing the
 specified qubit is dumped.
 </summary>
      <param name="q">The Qubit that iodentifies the product state factor.</param>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
      <param name="doMCC">An option that, if true, causes probabilities (complex magnitude squared) to be output
 for each state entry, rather than the complex amplitude.
 The default is to output the complex amplitude for each state.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Entropy(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Int32}})">
      <summary>
 Get the entanglement entropy
 </summary>
      <param name="alpha">Denotes the generalized entropy parameter: 1 for Von Neumann or 2 for Reny</param>
      <param name="qPos">qubit position, 0 to nQubits (based on order)</param>
      <param name="order">Int list of qubit order to wind up in []=use results of previous call (optional=[0..N-1])</param>
      <returns>Entropy value</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Ket.Item(System.Int32)">
      <summary>
 Get a specific qubit in our state (by qubit ID)
</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Ket.MaxEntangled">
      <summary>
 Max entangled that we've seen (reset during Reset())
</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.NormDiff(Microsoft.Research.Liquid.CVec)">
      <summary>
 Get L2 Norm of the difference of two ket vectors
 </summary>
      <param name="v2">Target ket vector to diff (obtained by ket.Single())</param>
      <returns>L2 Norm of the difference</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Prob1(Microsoft.Research.Liquid.Qubit)">
      <summary>
 Get the probability of measuring 1 for a single qubit
 </summary>
      <param name="q">Qubit to "fake" measure</param>
      <returns>probability</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.ProbOdd(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.FSharpOption{System.String})">
      <summary>
 Get the probability of measuring odd parity for a set of qubits
 </summary>
      <param name="qs">Qubits to fake measure</param>
      <param name="basis">String of basis to use for each qubit (optional="Z")</param>
      <returns>Probability of odd parity</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Probs(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Get the state probabilities for a list of qubits (l.e. 10 qubits)
 </summary>
      <param name="qs">Qubits to fake measure</param>
      <returns>Array of state values (low bit=first qubit requested)</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Purity">
      <summary>
 Finds the purity of each qubit in this Ket. NOT OPTIMIZED.
 </summary>
      <returns>An array of purities</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Ket.Qubits">
      <summary>
 Get all qubits in ID order
</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Ket.RandSeed">
      <summary>
 Force the pseudo-random number gen to a known initial state
</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Read(System.IO.BinaryReader)">
      <summary>
 Reads a new state vector from a binary stream.
 Note that this routine is only intended to read vectors written with the
 <see cref="M:Microsoft.Research.Liquid.Ket.Write(System.IO.BinaryWriter)">Write</see> method.
 <seealso cref="M:Microsoft.Research.Liquid.Ket.Read(System.String)" /></summary>
      <param name="br">The stream from which the vector should be read.</param>
      <returns>The new Ket</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Read(System.String)">
      <summary>
 Reads a new state vector from a file.
 Note that this routine is only intended to read vectors written with the
 <see cref="M:Microsoft.Research.Liquid.Ket.Write(System.String)">Write</see> method.
 <seealso cref="M:Microsoft.Research.Liquid.Ket.Read(System.IO.BinaryReader)" /></summary>
      <param name="file">The name of the file from which the state vector should be read.</param>
      <returns>The new Ket</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Reset(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.Bit})">
      <summary>
 Resets this Ket to an initial state with a specified number of qubits.
 </summary>
      <param name="want">An optional new qubit count.
 The default is to keep the same number of qubits.</param>
      <param name="init">An optional initial value for all qubits.
 The default is Zero.</param>
      <returns>The new Qubits in this Ket</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Ket.Rnd">
      <summary>
 Ask for a random number generator
</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Single(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Int32}})">
      <summary>
 Treats this Ket as if all of its qubits are entangled.
 </summary>
      <param name="order">Optionally, a list specifying a new order for the qubits.
 The default is for qubits to remain in their current order.</param>
      <returns>A CVec that contains the single state vector.
 Note that it is unsafe to modify this vector.</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Ket.Symbol(System.String)">
      <summary>
 Symbol table used to store the results of joint parity measurements.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.ToString">
      <summary>
 Gets a string representation of this Ket.
 This string may be extremely long; in general, it will have 2^N lines if there are N qubits in the Ket.
 Generally it is better to use the 
 <see cref="M:Microsoft.Research.Liquid.Ket.DumpKP(Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 Dump</see> method instead.
 </summary>
      <returns>The string representation</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Ket.TraceRun">
      <summary>
 Trace a circuit run (0=none 1=to log 2=to log and console, 3=Ket dumps)
</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Write(System.IO.BinaryWriter)">
      <summary>
 Writes this state vector to a binary stream.
 <seealso cref="M:Microsoft.Research.Liquid.Ket.Write(System.String)" /><seealso cref="M:Microsoft.Research.Liquid.Ket.Read(System.IO.BinaryReader)" /></summary>
      <param name="bw">The stream that this Ket should be written to.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Ket.Write(System.String)">
      <summary>
 Writes this state vector to a file.
 <seealso cref="M:Microsoft.Research.Liquid.Ket.Write(System.IO,BinaryWriter)" /><seealso cref="M:Microsoft.Research.Liquid.Ket.Read(System.String)" /></summary>
      <param name="file">The name of the file that this Ket should be written to.</param>
    </member>
    <member name="T:Microsoft.Research.Liquid.Noise">
      <summary>A complete noise model for a specific circuit.</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Noise.#ctor(Microsoft.Research.Liquid.Circuit,Microsoft.Research.Liquid.Ket,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.NoiseModel})">
      <summary>
 Creates a new Noise instance.
 </summary>
      <param name="circ">The circuit to apply noise to.</param>
      <param name="ket">The Ket to use for noise model.</param>
      <param name="models">A list of noise models to use, in decreasing precedence order.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Noise.DampProb(System.Int32)">
      <summary>
 The probability of amplitude-damping noise on a qubit.
 This allows different qubits to have different amplitude damping probabilities.
 </summary>
      <param name="id">The ID of the qubit</param>
      <param name="prob">The amplitude damping noise probability.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Noise.DampProbs">
      <summary>
 (Set only)
 The amplitude damping probability for all qubits.
 Use <see cref="P:Microsoft.Research.Liquid.Noise.DampProb(System.Int32,System.Double)">DampProb</see>
 to get or set the amplitude damping probaility for a single qubit.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Noise.DefaultNoise(System.Double)">
      <summary>
 Creates a default noise model.
 The new noise model has depolarizing noise on all qubits,
 and all gates have unit expected duration.
 </summary>
      <param name="prob">The probability of depolarizing noise occuring per unit of time.</param>
      <returns>The new noise model.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Noise.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Dumps noise statistics from the last run.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
      <param name="doStats">An option to dump full statistics.
 The default is false, in which case summary statistics per gate pattern are displayed.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Noise.ECgates">
      <summary>
 The list of wrap gates that are part of error-correcting circuits, by name.
 A name may end with "*" to indicate a wildcard.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Noise.Idle">
      <summary>
 (Set only)
 The idle gate.
 By default, I (the identity) is the idle gate.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Noise.LogGates">
      <summary>
 Whether or not to log gate execution to noise statistics during Run().
 Gate execution log entires will be marked with detail="!".
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Noise.Models">
      <summary>
 The noise models from last run.
 This provides access to the detailed statistics.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Noise.NoNoise">
      <summary>
 The list of noiseless gates, by name.
 A name may end with "*" to indicate a wildcard.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Noise.Run(Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.Ket})">
      <summary>
 Runs a circuit with this noise model.
 </summary>
      <param name="ket2">An optional state vector to use to re-initialize execution.
 If provided, this Ket is used for the run and all times and statistics are reset.
 If not provided, then execution continues from the state after the last Run.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Noise.Stats">
      <summary>
 The error statistics from the last run.
 Statistics are kept in reverse time order.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Noise.TraceNoise">
      <summary>
 Whether or not to trace noise to the log as it's inserted.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Noise.TraceWrap">
      <summary>
 Whether or not to trace wrap gates to the log as they're executed.
 </summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.NoiseEvents">
      <summary>
 Noise statistics that are tracked for normal and error-correcting gates.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.NoiseEvents.Accum(Microsoft.Research.Liquid.NoiseEvents)">
      <summary>Increments this instance with counts from another instance.</summary>
      <param name="y">The instance containing counts to add to this instance's counts.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseEvents.applied">
      <summary>The number of times noise has been applied</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseEvents.count">
      <summary>The number of times the model has been executed</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.NoiseEvents.Default">
      <summary>Creates a new instance with all counts initialized to 0.</summary>
      <returns>The new instance.</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseEvents.events">
      <summary>The number of noise events</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.NoiseEvents.Reset">
      <summary>Resets all counters back to 0.</summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.NoiseModel">
      <summary>A noise model for a particular type of gate (or set of gates).</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.NoiseModel.Default(Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.FSharpOption{System.String}}}}}})">
      <summary>Creates a default noise model that will apply to all gates.</summary>
      <param name="modelFunc">The noise function to apply.</param>
      <returns>A noise model that will apply the given function to all gates,
 to a single qubit, and initialized with zero statistics.</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseModel.ecEvents">
      <summary>Accumulated noise statistics for error-correcting gates.</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseModel.func">
      <summary>The noise function to execute.</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseModel.gate">
      <summary>The name of the gate that this noise model applies to. 
 The name may end with an asterisk, '*', to indicate a wildcard match.</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseModel.gateEvents">
      <summary>Accumulated noise statistics for normal gates.</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseModel.maxQs">
      <summary>The maximum number of qubits to apply noise to.</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseModel.time">
      <summary>The expected duration of the gate. By convention, an idle gate takes 1.0 units.</summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.NoiseStat">
      <summary>Statistics tracked for each time that noise is applied.</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseStat.detail">
      <summary>User-defined noise details from the noise function output.</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseStat.dur">
      <summary>The duration of the noise applicationm.</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseStat.ecGate">
      <summary>Whether or not thie was flagged as an error correcting gate.</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseStat.model">
      <summary>The noise model that was applied.</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseStat.qs">
      <summary>The qubits that noise was applied to.</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.NoiseStat.time">
      <summary>When noise was applied during the simulated execution.</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.NoiseStat.ToString">
      <summary>
 Returns a string representation of this noise statistic.
 </summary>
      <returns>The string</returns>
    </member>
    <member name="T:Microsoft.Research.Liquid.NoisyMats">
      <summary>
 Utility class for computing a Pauli rotation matrix.
 This is used to run quantum chemistry circuits with noise injected.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.NoisyMats.GenRot(System.Double,Microsoft.Research.Liquid.CSMat)">
      <summary>
 Generates a Pauli-based rotation matrix for an arbitrary angle.
 </summary>
      <param name="theta">The rotation angle.</param>
      <param name="mParent">The base matrix for the rotation.
 This must be an idempotent Hermitian matrix.</param>
      <returns>A rotation matrix, exp(i*theta/2*mParent).</returns>
    </member>
    <member name="T:Microsoft.Research.Liquid.Operations">
      <summary>
 The Operations module provides definitions of basic gates.
 It also includes some handy operators for manipulating qubit lists,
 and some operations for building gates from existing gates.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.Adj(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs the adjoint of the parent gate.
 This only works if the parent gate is a unitary gate.
 </summary>
      <param name="f">The gate to take the adjoint of</param>
      <param name="qs">A list of qubits which are passed to the adjoint.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.BC(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a gate under classical control.
 The parent gate will be executed if the control qubit has a measured value of One.
 <seealso creaf="M:Microsoft.Research.Liquid.Operations.BCany(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},System.Boolean},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})" /></summary>
      <param name="f">The parent gate to control</param>
      <param name="qs">A list of qubits. 
 The head qubit is the control qubit; its measured state determines whether or not
 the parent gate is executed.
 The tail of the list is passed to the parent gate if it is executed.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.BCany(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},System.Boolean},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a gate under classical control.
 This gate allows an arbitrary condition to be specified.
 The parent gate will be executed if the condition function evaluates to true.
 <seealso cref="M:Microsoft.Research.Liquid.Operations.BC(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})" /></summary>
      <param name="cnt">The count of binary control bits. 
 These bits will not be passed to the parent gate.</param>
      <param name="tst">The condition function that controls execution of the parent gate.</param>
      <param name="f">The parent gate to control</param>
      <param name="qs">A list of qubits. 
 The initial <paramref name="cnt" /> qubits are provided to the condition function,
 and the remainder are passed to the parent gate if it is executed.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.CCgate(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a parent gate under two-qubit quantum control.
 The parent must be a unitary gate.
 </summary>
      <param name="f">The gate to control.</param>
      <param name="qs">The first two qubits are the control, and the remainder are passed to the parent gate.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.CCNOT(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Toffoli or Controlled-Controlled-NOT gate
 </summary>
      <param name="qs">The first two qubits in the list are the control qubits, and the third qubit is the target,</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.Cgate(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a parent gate under quantum control.
 The parent must be a unitary gate.
 </summary>
      <param name="f">The gate to control.</param>
      <param name="qs">The first qubit is the control qubit, and the remainder are passed to the parent gate.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.CgateNC(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a parent gate under quantum control.
 The parent must be a unitary gate.
 The resulting gate is not cached.
 </summary>
      <param name="f">The gate to control.</param>
      <param name="qs">The first qubit is the control qubit, and the remainder are passed to the parent gate.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.CNOT(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a quantum-controlled NOT gate
 </summary>
      <param name="qs">The head qubit is the control qubit, the second qubit is the target.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.CZ(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a quantum-controlled Pauli Z gate. 
 </summary>
      <param name="qs">The head qubit is the control qubit, the second qubit is the target.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.H(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Hadamard gate. 
 </summary>
      <param name="qs">The head qubit of this list is operated on.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.I(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Pauli I (identify) gate. 
 </summary>
      <param name="qs">The head qubit of this list is operated on.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.JM(System.String,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a joint parity measurement in the given basis on a list of qubits.
 The result of the measurement is stored in the Ket's symbol table.
 The state vector is collapsed according to the result of the measurement.
 </summary>
      <param name="tag">If not empty, the symbol name to store the measurement result under.
 See <see cref="P:Microsoft.Research.Liquid.Ket.Symbol(System.String,System.Int32)">Ket.Symbol</see>.</param>
      <param name="basis">The basis to measure in.
 This may be a string of any length, including empty, made up of X, Y, and Z characters.
 Each character is used to specify the basis for the corresponding qubit being measured.
 If there are more qubits than bases specified, then the last basis character is repeated.
 If this is an empty string, then it is treated as "Z", which performs a joint measurement
 of all qubits in the computational basis.</param>
      <param name="qs">The list of qubits to jointly measure.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.JMx(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a joint parity measurement in the X basis on a list of qubits.
 The result of the measurement is stored in the Ket's symbol table.
 The state vector is collapsed according to the result of the measurement.
 </summary>
      <param name="tag">If not empty, the symbol name to store the measurement result under.
 See <see cref="P:Microsoft.Research.Liquid.Ket.Symbol(System.String,System.Int32)">Ket.Symbol</see>.</param>
      <param name="qs">The list of qubits to jointly measure.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.JMz(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a joint parity measurement in the computational basis on a list of qubits.
 The result of the measurement is stored in the Ket's symbol table.
 The state vector is collapsed according to the result of the measurement.
 </summary>
      <param name="tag">If not empty, the symbol name to store the measurement result under.
 See <see cref="P:Microsoft.Research.Liquid.Ket.Symbol(System.String,System.Int32)">Ket.Symbol</see>.</param>
      <param name="qs">The list of qubits to jointly measure.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.Label(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Adds a label to a circuit drawing.
 The label will appear above the line representing the qubit,
 in the center of the current column.
 The label will take up no logical space; it will not fill the current cell.
 </summary>
      <param name="nam">The string to use as a label.</param>
      <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.LabelC(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Adds a label to a circuit drawing.
 The label be centered in and will fill the current cell.
 </summary>
      <param name="nam">The string to use as a label.</param>
      <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.LabelCD(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Adds a framed label to a circuit drawing.
 The label be centered in and will fill the current cell.
 The label will have a box drawn tightly around it.
 </summary>
      <param name="nam">The string to use as a label.</param>
      <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.LabelD(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Adds a label to a circuit drawing.
 The label will appear below the line representing the qubit,
 in the center of the current column.
 The label will take up no logical space; it will not fill the current cell.
 </summary>
      <param name="nam">The string to use as a label.</param>
      <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.LabelL(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Adds a label to a circuit drawing.
 The label will appear centered on the line representing the qubit,
 on the left side of the current column.
 The label will take up no logical space; it will not fill the current cell.
 </summary>
      <param name="nam">The string to use as a label.</param>
      <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.LabelR(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Adds a label to a circuit drawing.
 The label will appear centered on the line representing the qubit,
 on the right side of the current column.
 The label will take up no logical space; it will not fill the current cell.
 </summary>
      <param name="nam">The string to use as a label.</param>
      <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.LabelRaw(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Adds a raw label to a circuit drawing.
 The provided string should contain the
 <see href="http://physics.unm.edu/CQuIC//Qcircuit/">Q-Circuit</see>
 commands used to draw the label.
 Note that labels drawn using this gate will only appear when rendered to "qc" format.
 </summary>
      <param name="cmd">The string to use to draw the label.</param>
      <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.LabelU(System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Adds a label to a circuit drawing.
 The label will appear above the line representing the qubit,
 in the center of the current column.
 The label will take up no logical space; it will not fill the current cell.
 </summary>
      <param name="nam">The string to use as a label.</param>
      <param name="qs">A list of qubits, the first of which determines the
 vertical positioning of the label.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.LoadCache">
      <summary>
 Preload the cache with basic gates: Paulis, measurement, Hadamard, phase, CNOT, Toffoli, swap, and T.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.M(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a measurement of a single qubit in the computational basis.
 The result of the measurement is stored in the measured qubit; 
 see <see cref="P:Microsoft.Research.Liquid.Qubit.Bit(Microsoft.Research.Liquid.Bit)">Qubit.Bit</see>.
 The state vector is collapsed according to the result of the measurement.
 The measured qubit becomes "classical" and must be reset before any further
 quantum gates are performed on it.
 </summary>
      <param name="qs">A list of qubits; the head of the list is measured.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.Native(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs any desired native operations at this point in the circuit.
 <seealso cref="M:Microsoft.Research.Liquid.Operations.NativeDbg(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})" /></summary>
      <param name="f">The native function to call.</param>
      <param name="qs">The list of qubits to pass to the native operation.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.NativeDbg(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs any desired native operations at this point in the circuit.
 This version doesn't appear in a circuit drawing.
 <seealso cref="M:Microsoft.Research.Liquid.Operations.Native(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})" /></summary>
      <param name="f">The native function to call.</param>
      <param name="qs">The list of qubits to pass to the native operation.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.op_BangBang(System.Object)">
      <summary>
 In F# code, this operator is named !!.
 Builds a list of Qubits from a wide variety of possible inputs.
 </summary>
      <param name="qs">The value to interpret as a list of Qubits.</param>
      <returns>A list of Qubits</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.op_BangLess(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 In F# code, this operator is named !&lt;.
 Gets the gate definition from a gate function.
 This is usually used to discover the "parent" gate.
 </summary>
      <param name="f">The gate function we want the Gate for.</param>
      <param name="qs">A list of Qubits that can be used to find the gate.</param>
      <returns>The Gate corresponding to the gate function.
 Note that if f is not a gate function, this function will raise an exception.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.op_GreaterBangLess``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit}},System.Object,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 In F# code, this operator is named &gt;!&lt;.
 Applies a function to each qubit in a list, passing a parameter to the function as well as each Qubit.
 The parameter values may be a list of a single value which is then passed to each invocation.
 </summary>
      <param name="f">The function to call.
 The extra parameter must be the first argument to the function.</param>
      <param name="args">Either a list of arguments, one per Qubit, or a single value
 that is passed with each Qubit.</param>
      <param name="qs">The list of qubits to iterate over.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.op_GreaterLess(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 In F# code, this operator is named &gt;&lt;.
 Applies a function to each qubit in a list of Qubits.
 </summary>
      <param name="f">The gate function to call.</param>
      <param name="qs">The list of qubits to iterate over.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.PC(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},System.Boolean},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a gate based on a classical condition.
 The parent gate is executed if the test function returns true.
 Typically this condition is based on the results of one or more joint parity measurements.
 <seealso cref="P:Microsoft.Research.Liquid.Ket.Symbol(System.String,System.Int32)" /></summary>
      <param name="lbl">A label for drawing.</param>
      <param name="tst">The test function used to control execution of the parent gate.</param>
      <param name="f">The parent gate to control</param>
      <param name="qs">A list of qubits which will be passed to the parent gate
 if it is executed.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.R(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a 2pi/2^K rotation gate gate. 
 </summary>
      <param name="k">The rotation parameter</param>
      <param name="qs">The head qubit of this list is operated on.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.Reset(Microsoft.Research.Liquid.Bit,Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Resets a qubit to a specified initial state after it has been measured.
 This allows quantum gates to be performed against the collapsed qubit.
 See the <see cref="">M</see> gate.
 </summary>
      <param name="b">The initial state of the reset qubit, either Zero or One.</param>
      <param name="qs">A list of qubits; the head of the list is reset.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.Restore(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Resets a qubit after it has been measured.
 This allows quantum gates to be performed against the collapsed qubit.
 The initial state of the qubit will be its last measured state.
 See the <see cref="">M</see> gate.
 </summary>
      <param name="qs">A list of qubits; the head of the list is reset.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.S(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a phase gate. 
 </summary>
      <param name="qs">The head qubit of this list is operated on.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.SWAP(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a swap gate, exchanging the quantum states of two qubits.
 </summary>
      <param name="qs">The states of the first two qubits in the list are swapped.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.T(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a pi/8 gate. 
 </summary>
      <param name="qs">The head qubit of this list is operated on.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.T_BC(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},System.Tuple{Microsoft.Research.Liquid.Bit,System.Int32}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a transverse classically-controlled gate.
 </summary>
      <param name="decode">The code-specific decode function that takes a list of measured qubits 
 and returns a logical value (One or Zero) and the Hamming distance from the current state 
 to a valid code state.</param>
      <param name="f">The (transverse) parent gate to control</param>
      <param name="qs">The first codeSize qubits in the list are passed to the <paramref name="decode" /> 
 function to compute a logical Zero or One state. 
 If the decoded state is One, then the remaining qubits are passed to the parent gate.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.Transverse(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Expands a parent gate to a transverse version.
 </summary>
      <param name="cCnt">The total number of qubits in code</param>
      <param name="f">The parent gate to expand</param>
      <param name="qs">The qubits that final gate will operate on</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.X(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Pauli X gate. 
 </summary>
      <param name="qs">The head qubit of this list is operated on.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.Y(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Pauli Y gate. 
 </summary>
      <param name="qs">The head qubit of this list is operated on.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Operations.Z(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Performs a Pauli Z gate. 
 </summary>
      <param name="qs">The head qubit of this list is operated on.</param>
    </member>
    <member name="T:Microsoft.Research.Liquid.QECC">
      <summary>
 Base class for quantum error correcting codes.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.QECC.#ctor(System.Int32,System.Int32,Microsoft.Research.Liquid.Circuit)">
      <summary>
 Initializes a Quantum Error Correcting Circuit (QECC).
 This base constructor must be called by all derived constructors.
 </summary>
      <param name="aCnt">The number of ancilla qubits.
 By convention ancillae come first in the state vector, before data and syndrome qubits.
 Ancilla qubits are shared across all logical qubits and are for use during decoding,
 measurement, and other operations; they are not syndrome qubits.</param>
      <param name="cCnt">The code size; that is, the number of physical qubits 
 (data and syndrome) per logical qubit.</param>
      <param name="tgt">The target Circuit to build an error-correcting circuit for.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.QECC.Circuit">
      <summary>
 The error-correcting circuit built by
 <see cref="M:Microsoft.Research.Liquid.QECC.Compile">Compile</see>.
 The circuit will be built now if it hasn't already been.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.QECC.Compile">
      <summary>
 Compiles the target circuit into an error-correcting version.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.QECC.Decode(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Decodes a set of measured physical qubits to get the measured value for a logical qubit.
 </summary>
      <param name="qs">The physical qubits to decode.
 They must already have been measured.</param>
      <returns>A tuple containing the logical measured value of the logical qubit, either Zero or One,
 and the Hamming distance from the physical state to the code space.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.QECC.GetMeasured(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Gets the measured values of the physical qubits that make up a logical qubit
 and returns them combined into a single integer, one bit per qubit.
 </summary>
      <param name="qs">The set of qubits to read.
 This should be the set of physical (data and syndrome) qubits for one logical qubit.</param>
      <returns>The total measured value of the qubits.
 The value of the first qubit in the list goes into the left-most (most significant) bit in the result.
 </returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.QECC.Inject(System.Double)">
      <summary>
 Injects dephasing errors with the given probability into the error-correcting circuit.
 </summary>
      <param name="prob">The probability of an error on execution of a gate.
 Each qubit input to the gate has this same chance of a dephasing error.
 If an error is injected, it will be either an X, Y, or Z error, with equal probability.
 Note that errors are never injected on ancilla qubits.</param>
      <returns>A tuple containing the new Circuit with errors injected as the first item
 and a list of injected error counts as the second.
 The error count list contains the count of X, Y, and Z errors injected, in that order.</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.QECC.Ket">
      <summary>
 The state vector for the compiled code.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.QECC.Log2Phys(System.Int32)">
      <summary>
 Gets the physical qubits that make up a logical qubit.
 </summary>
      <param name="w">The wire ID of the logical qubit in the original non-error correcting circuit.</param>
      <returns>A list of the physical qubits that implement the logical qubit.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.QECC.Prep(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 A gate function that prepares a logical |0&gt; qubit.
 This gets compiled into the error-correcting circuit by the Compile method.
 </summary>
      <param name="qs">The physical qubits for the logical qubit.
 This contains both data and syndrome qubits, but no ancillae.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.QECC.Replace(Microsoft.Research.Liquid.Gate)">
      <summary>
 Gets a replacement physical gate for an input logical gate.
 The replacement may wrap a full Circuit.
 </summary>
      <param name="g">The logical gate function to replace.</param>
      <returns>An option holding a physical gate that implements the logical gate.
 If there is no physical implementation of the logical gate, then 
 None is returned.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.QECC.Syndrome(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 A gate function that measures the physical qubits for a single logical qubit
 and applies any necessary corrections.
 This gets compiled into the error-correcting circuit by the Compile method.
 </summary>
      <param name="qs">The ancilla qubits followed by physical qubits for the logical qubit.
 The number of ancillae was passed to the QECC constructor.</param>
    </member>
    <member name="T:Microsoft.Research.Liquid.Qubit">
      <summary>
 Represents a quantum bit.
 New Qubits are created using the 
 <see cref="T:Microsoft.Research.Liquid.Ket">Ket</see> Add methods.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Qubit.Bit">
      <summary>
 The measured value of a qubit in the computational basis.
 This will be Unknown if the qubit has not been measured since it last interacted.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Qubit.Dump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
      <summary>
 Dump this qubit's state.
 </summary>
      <param name="f">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The optional indentation level. The default is 0.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Qubit.Entangled">
      <summary>
 Whether or not this qubit is entangled.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Qubit.Id">
      <summary>
 Wire number in Ket vector
</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Qubit.Ket">
      <summary>
 State we belong to
</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Qubit.One">
      <summary>
 A Complex vector that represents the state |1&gt; in the computational basis.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Qubit.Prob1">
      <summary>
 The probability of this qubit being 1.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Qubit.ReAnimate(Microsoft.Research.Liquid.Bit)">
      <summary>
 Reanimates this qubit and sets its state vector to |0&gt; or |1&gt;.
 Reanimation means that this qubit is treated as unmeasured and eligible
 for quantum operations.
 This method will raise an exception if the qubit is unmeasured or entangled.
 </summary>
      <param name="b">The Bit value to set this qubit's state to.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Qubit.ReAnimate(Microsoft.Research.Liquid.CVec)">
      <summary>
 Reanimates this qubit and sets its state vector.
 Reanimation means that this qubit is treated as unmeasured and eligible
 for quantum operations.
 This method will raise an exception if the qubit is unmeasured or entangled.
 </summary>
      <param name="v">The Complex vector to set this qubit's state to.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Qubit.ShowMag">
      <summary>
 Creates a string representation of this Qubit.
 The representation shows the probabilities of measuring this Qubit
 in the computational |0&gt; and |1&gt; states.
 <seealso cref="M:Microsoft.Research.Liquid.Qubit.ToString()" /></summary>
      <returns>The string representation</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Qubit.State">
      <summary>
 The state vector for this qubit, if it is unentangled.
 This property will raise an exception if the qubit is entangled.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Qubit.StateSet(Microsoft.Research.Liquid.Bit)">
      <summary>
 Sets the state vector for this qubit to |0&gt; or |1&gt;, if it is unentangled.
 This method will raise an exception if the qubit is entangled.
 </summary>
      <param name="b">The Bit value to set this qubit's state to.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Qubit.StateSet(Microsoft.Research.Liquid.Complex,Microsoft.Research.Liquid.Complex)">
      <summary>
 Sets the state vector for this qubit, if it is unentangled.
 This method will raise an exception if the qubit is entangled.
 </summary>
      <param name="c1">The complex |0&gt; amplitude to set this qubit's state to.</param>
      <param name="c2">The complex |1&gt; amplitude to set this qubit's state to.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Qubit.StateSet(Microsoft.Research.Liquid.CVec)">
      <summary>
 Sets the state vector for this qubit, if it is unentangled.
 This method will raise an exception if the qubit is entangled.
 </summary>
      <param name="v">The Complex vector to set this qubit's state to.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Qubit.StateSet(System.Double,System.Double,System.Double,System.Double)">
      <summary>
 Sets the state vector for this qubit, if it is unentangled.
 This method will raise an exception if the qubit is entangled.
 </summary>
      <param name="r1">The real part of the |0&gt; amplitude to set this qubit's state to.</param>
      <param name="i1">The imaginary part of the |0&gt; amplitude to set this qubit's state to.</param>
      <param name="r2">The real part of the |1&gt; amplitude to set this qubit's state to.</param>
      <param name="i2">The imaginary part of the |1&gt; amplitude to set this qubit's state to.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Qubit.ToString">
      <summary>
 Creates a string representation of this Qubit.
 The representation shows the current state of the qubit if it is unentangled.
 <seealso cref="M:Microsoft.Research.Liquid.Qubit.ShowMag()" /></summary>
      <returns>The string representation</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Qubit.Type">
      <summary>
 The type of the qubit.
 This is only used for noise modeling.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Qubit.Zero">
      <summary>
 A Complex vector that represents the state |0&gt; in the computational basis.
 </summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.RunMode">
      <summary>
 Trotterization types.
 </summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.Spin">
      <summary>
 Hamiltonian for spin systems, such as the Ising model or a spin glass.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Spin.#ctor(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.SpinTerm},System.Int32,Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.RunMode})">
      <summary>
 Creates a spin Hamiltonian from a set of spin terms.
 </summary>
      <param name="_spinTerms">The list of SpinTerms that together make up the spin Hamiltonian.</param>
      <param name="_numSpins">The number of spins in the system.</param>
      <param name="_runMode">The Trotterization type to use.
 This must be one of Trotter1, Trotter1X, or Trotter2.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Spin.#ctor(System.Collections.Generic.Dictionary{System.Int32,System.Double},System.Collections.Generic.Dictionary{System.Tuple{System.Int32,System.Int32},System.Double})">
      <summary>
 Creates a spin Hamiltonian for simple systems that only have single spin biases and two-spin couplings. 
 The count of spins is inferred.
 </summary>
      <param name="hs">A Dictionary that maps a qubit id to that qubit's bias strength (Z term coefficient).</param>
      <param name="Js">A Dictionary that maps a pair of qubit id's to the pair's coupling strength (ZZ coefficient).</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Spin.Copy">
      <summary>
 Returns an instance of Spin with the same Hamiltonian parameters as this instance. 
 Simulation parameters such as run time and Trotter number are <b>not</b> copied.
 </summary>
      <returns>Copy of this instance</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Spin.currentCirc">
      <summary>
 The last (grown) circuit that was run.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Spin.EnergyExpectation(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Double[]},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit}})">
      <summary>
 Finds the expectation value of the Hamiltonian.
 That is, given a state vector |<i>psi</i>&gt;, 
 this method computes &lt;<i>psi</i>|<b>H</b>|<i>psi</i>&gt;.
 </summary>
      <param name="stdev">Whether or not to evaluate the standard deviation as well.</param>
      <param name="anneal">An optional array of annealing values to use.
 The default is to use the most recent annealing values.</param>
      <param name="qubits">An optional state vector to take the expectation value against.
 The default is to use this.Ket.Qubits; that is, the qubits from the current Ket vector.</param>
      <returns>A tuple of the expectation value and standard deviation.
 The standard deviation will be 0.0 if it was not computed.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Spin.Ferro(System.Int32,System.Int32,System.Double,System.Double,System.Double,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Double,System.Double}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.Unit},System.Double}}})">
      <summary>
 Test adiabatic evolution with a ferro-magnetic chain
 </summary>
      <param name="repeat">How many tests to run</param>
      <param name="sCnt">How many qubits</param>
      <param name="h0">-1,0,1 = left  most down, random, up</param>
      <param name="hn">-1,0,1 = right most down, random, up</param>
      <param name="J">coupling: 1=ferro -1=anti 0=none</param>
      <param name="gammalambda">List of (time,gamma,lambda) tuples that define the annealing schedule (optional=[(30,0.0,1.0)])</param>
      <param name="runonce">true=run the simulation once and perform repeated 'virtual measurements'; false=run the simulation and measure each time (optional=false)</param>
      <param name="decohereModel">Decoherence probability per qubit per timestep [(gate,prob) list] optional=None</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Spin.lastAnneal">
      <summary>
 The last set of annealing coefficients that were applied.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Spin.lastRawCirc">
      <summary>
 The last (ungrown) circuit that was run.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Spin.Peek(Microsoft.FSharp.Core.FSharpOption{System.Double[]})">
      <summary>
 Peeks at the current Hamiltonian matrix.
 This is based on the most recently grown circuit.
 </summary>
      <param name="anneal">An optional array of annealing values to use.
 The default is to use the most recent annealing values.</param>
      <returns>A sparse matrix representation of the Hamiltonian</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Spin.Prep">
      <summary>
 Prepares the qubit state for a run.
 All qubits are resets and initialized to the ground state.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Spin.Run(System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Double[]}},Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">
      <summary>
 Runs the simulation.
 This is a highly optimized implementation.
 </summary>
      <param name="dt">The number of timesteps to run.</param>
      <param name="schedule">The annealing schedule to use.
 Each entry in the list is a tuple whose first entry is a time step and whose second entry is an 
 array of annealing values.
 Annealing values for time steps in between entries are computed by linearly interpolating
 between those for the previous and next entries.
 The list must be in ascneding order by time step.
 </param>
      <param name="gp">Optional grow parameters for the resulting circuit.
 The default is GrowGates with maxWires of 11.
 See <see cref="T:Microsoft.Research.Liquid.GrowPars">GrowPars</see> for more details.</param>
      <returns>The number of decoherence events which occured during the step.
 Note that this will be zero unless a decoherence model has been set on this instance.</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Spin.runMode">
      <summary>
 The run mode.
 Note that setting this property will force a new circuit to be generated.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Spin.Step(System.Double[],Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.GrowPars})">
      <summary>
 Performs a single timestep of simulation.
 </summary>
      <param name="angles">The vector of annealing coefficients to be used in this step.</param>
      <param name="gp">Optional grow parameters for the resulting circuit.
 The default is GrowGates with maxWires of 11.
 See <see cref="T:Microsoft.Research.Liquid.GrowPars">GrowPars</see> for more details.</param>
      <returns>The number of decoherence events which occured during the step.
 Note that this will be zero unless a decoherence model has been set on this instance.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Spin.Test(System.String,System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Double[]}},System.Int32,Microsoft.Research.Liquid.Spin,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.Unit},System.Double}}})">
      <summary>
 Executes a set of simulation runs for a spin Hamiltonian.
 </summary>
      <param name="tag">The output label for logging.</param>
      <param name="repeats">The number of simulations to run.</param>
      <param name="trotter">The Trotter number to use.</param>
      <param name="schedule">The annealing schedule to use.
 Each entry in the list is a tuple whose first entry is a time step and whose second entry is an 
 array of annealing values.
 Annealing values for time steps in between entries are computed by linearly interpolating
 between those for the previous and next entries.
 The list must be in ascneding order by time step.</param>
      <param name="res">The resolution of the simulation, in time steps. 
 Larger values may increase speed but will reduce the granularity of output.
 Note that this must evenly divide the final time in the annealing schedule.</param>
      <param name="spin">The actual Hamiltonian to be simulated.</param>
      <param name="runonce">An option to only run the simulation once and perform repeated 'virtual measurements'.
 The default is false, which means to run the simulation and measure each time.</param>
      <param name="decohereModel">An optional decoherence model to use for this simulation.
 See <see cref="P:Microsoft.Research.Liquid.Hamiltonian.decohereModel(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.Unit},System.Double}})">Hamiltonian.decohereModel</see> for more information.
 The default is no decoherence.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Spin.Test(System.String,System.Int32,System.Int32,System.Collections.Generic.Dictionary{System.Int32,System.Double},System.Collections.Generic.Dictionary{System.Tuple{System.Int32,System.Int32},System.Double},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,System.Double,System.Double}},System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.Unit},System.Double}}})">
      <summary>
 Executes a set of simulation runs for a spin Hamiltonian.
 </summary>
      <param name="tag">The output label for logging.</param>
      <param name="repeats">The number of simulations to run.</param>
      <param name="trotter">The Trotter number to use.</param>
      <param name="hs">A Dictionary that maps a qubit id to that qubit's bias strength (Z term coefficient).</param>
      <param name="Js">A Dictionary that maps a pair of qubit id's to the pair's coupling strength (ZZ coefficient).</param>
      <param name="gammalambda">List of (time,gamma,lambda) tuples that define the annealing schedule.
 Each entry in the list is a tuple whose first entry is a time step and whose second entry is an 
 array of annealing values.
 Annealing values for time steps in between entries are computed by linearly interpolating
 between those for the previous and next entries.
 The list must be in ascneding order by time step.</param>
      <param name="res">The resolution of the simulation, in time steps. 
 Larger values may increase speed but will reduce the granularity of output.
 Note that this must evenly divide the final time in the annealing schedule.</param>
      <param name="runonce">An option to only run the simulation once and perform repeated 'virtual measurements'.
 The default is false, which means to run the simulation and measure each time.</param>
      <param name="decohereModel">An optional decoherence model to use for this simulation.
 See <see cref="P:Microsoft.Research.Liquid.Hamiltonian.decohereModel(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{Microsoft.Research.Liquid.Qubit,Microsoft.FSharp.Core.Unit},System.Double}})">Hamiltonian.decohereModel</see> for more information.
 The default is no decoherence.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Spin.time">
      <summary>
 The current simulation time.
 Note that setting this property will force a new circuit to be generated.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Spin.trotterN">
      <summary>
 The Trotter number.
 Note that setting this property will force a new circuit to be generated.
 </summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.SpinTerm">
      <summary>
 A single term in a Spin Hamiltonian.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.SpinTerm.#ctor(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{System.Int32},System.Double)">
      <summary>
 Initializes a new SpinTerm instance.
 </summary>
      <param name="s">The numerical id, zero-based, of the annealing schedule corresponding to this term.</param>
      <param name="o">A function which performs the operation of this term over a given angle.</param>
      <param name="idx">A list of integer indices specifying the qubits to apply this term to.</param>
      <param name="a">The numerical coefficient ('strength') leading this term.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.SpinTerm.#ctor(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit},Microsoft.FSharp.Core.Unit}},System.Double)">
      <summary>
 Initializes a new SpinTerm instance.
 </summary>
      <param name="s">The numerical id, zero-based, of the annealing schedule corresponding to this term.</param>
      <param name="o">A function which performs the operation of this term over a given angle.</param>
      <param name="a">The numerical coefficient ('strength') leading this term.</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.SpinTerm.Amplitude">
      <summary>The numerical coefficient ('strength') leading this term.</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.SpinTerm.Schedule">
      <summary>The numerical id (zero-based) of the annealing schedule corresponding to this term.</summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.Stabilizer">
      <summary>
 A stabilizer-based simulator based on CHP by Scott Aaronson and Daniel Gottesman.
 See <see href="http://arxiv.org/abs/quant-ph/0406196">arXiv:quant-ph/0406196</see>
 for more details.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Stabilizer.#ctor(Microsoft.Research.Liquid.Circuit,Microsoft.Research.Liquid.Ket)">
      <summary>
 Creates a tableau to run a circuit in the stabilizer simulator.
 </summary>
      <param name="circ">The crcuit that will be run in stabilizer mode.</param>
      <param name="ket">The state vector that will be used for execution.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Stabilizer.Gaussian">
      <summary>
 Performs a Gaussian elimination to put the tableau in quasi upper triangluar form.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Stabilizer.Item(System.Int32)">
      <summary>
 The current measured value for a qubit.
 </summary>
      <param name="i">The index of the qubit in the simulator's state vector.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Stabilizer.Run(Microsoft.FSharp.Core.FSharpOption{Microsoft.Research.Liquid.Circuit},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
      <summary>
 Runs the circuit.
 </summary>
      <param name="circuit">An optional different circuit to run.
 This allows the tableau to be reused for different circuits.
 The default is to used the circuit the tableau was created with.</param>
      <param name="dumpAll">An option indicating that the tableau state should be
 written to the log after each gate application.
 The default is false, indicating not to log.</param>
      <param name="gaussian">An option indicating that the tableau state should
 be simplified using Gaussian elimination before being logged.
 This is ignored if <paramref name="dumpall" /> is false.
 The default is false, indicating not to perform Gaussian elimination.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Stabilizer.ShowState(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}},System.Int32)">
      <summary>
 Dumps the stabilizer tableau.
 </summary>
      <param name="f">The output function to use. 
 A common output function is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="level">The indentation level. </param>
    </member>
    <member name="T:Microsoft.Research.Liquid.Steane7">
      <summary>
 Implementation of a Steane 7-bit quantum error correcting code, [[7,1,3]], 
 based on the <see cref="T:Microsoft.Research.Liquid.QECC">QECC</see> class.
 <seealso cref="T:Microsoft.Research.Liquid.QECC" /></summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Steane7.#ctor(Microsoft.Research.Liquid.Circuit)">
      <summary>
 Constructs a Steane code implementation for a circuit.
 </summary>
      <param name="tgt">The target Circuit to build an error-correcting circuit for.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Steane7.Decode(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 Decodes a set of measured physical qubits to get the measured value for a logical qubit.
 </summary>
      <param name="qs">The physical qubits to decode.
 They must already have been measured.</param>
      <returns>A tuple containing the logical measured value of the logical qubit, either Zero or One,
 and the Hamming distance from the physical state to the code space.</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Steane7.NumFixed">
      <summary>
 The number of syndrome fixups performed.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Steane7.Prep(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 A gate function that prepares a logical |0&gt; qubit.
 This gets compiled into the error-correcting circuit by the Compile method.
 </summary>
      <param name="qs">The physical qubits for the logical qubit.
 This contains both data and syndrome qubits, but no ancillae.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Steane7.Syndrome(Microsoft.FSharp.Collections.FSharpList{Microsoft.Research.Liquid.Qubit})">
      <summary>
 A gate function that measures the physical qubits for a single logical qubit
 and applies any necessary corrections.
 This gets compiled into the error-correcting circuit by the Compile method.
 </summary>
      <param name="qs">The ancilla qubits followed by physical qubits for the logical qubit.
 The number of ancillae was passed to the QECC constructor.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Steane7.Test1">
      <summary>
 Tests the Steane7 QECC on a single logical qubit with forced X, Y, and Z error injections.
 </summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.Tests">
      <summary>
 A collection of sample Liquid simulations and tests,
 plus some utility routines to make it easier to write new samples.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__Big">
      <summary>
 Runs an entanglement test for state vectors from 16 to 22 qubits in size.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__Chem(System.String)">
      <summary>
 Runs a simple quantum chemistry simulation.
 This is the same as the 
 <see cref="">__ChemFull</see> sample,
 with common values for the detailed parameters: test 0, 32 Trotter steps, first-order Trotter,
 28 bits of accuracy, and no additional options.
 See the Users Manual for more information.
 </summary>
      <param name="mol">The name of the molecule to simulate.
 Entering an empty string, "", will display the list of available molecules.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__ChemFull(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Int32)">
      <summary>
 Runs a quantum chemistry simulation.
 See the Users Manual for more information.
 </summary>
      <param name="mol">The name of the molecule to simulate.
 Entering an empty string, "", will display the list of available molecules.</param>
      <param name="test">The test number to run, from the .dat file.</param>
      <param name="opts">A string of any options you want to set.
 See the Users Manual for more information.</param>
      <param name="trot">The Trotter parameter; that is, number of Trotter steps per time step.</param>
      <param name="bits">The number of bits of accuracy desired in the phase estimation.</param>
      <param name="order">The order of Trotter approximation to use, 1 or 2.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__Correct">
      <summary>
 Test various permutations for correctness using teleport
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__EIGS">
      <summary>
 Validates that LAPACK is properly installed.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__Entangle1(System.Int32)">
      <summary>
 Runs a simple gate sequence that entangles all the qubits in the state vector.
 </summary>
      <param name="entSiz">The number of qubits desired in the state vector.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__Entangle2(System.Int32)">
      <summary>
 Runs a simple gate sequence that entangles all the qubits in the state vector.
 The sequence is run three different ways to demonstrate the difference in timings.
 </summary>
      <param name="entSiz">The number of qubits desired in the state vector.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__Entangles">
      <summary>
 Runs 100 entanglement tests on 16 qubits to show the statistics on the bits measured. 
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__EntEnt">
      <summary>
 Demonstrates a couple of simple entanglement entropy calculations.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__EPR">
      <summary>
 Renders a small EPR circuit that entangles two qubits.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__Ferro(System.Boolean,System.Boolean)">
      <summary>
 Simulates a ferromagnetic chain using a first-quantized Hamiltonian.
 </summary>
      <param name="full">Whether to run all chain variations (isolated, ferromagnetic,
 anti-ferromagnetic, freeze up, freese down, and freeze up/down) or just the last 
 variation, freeze up/down.</param>
      <param name="runonce">For each variation, whether to run the circuit once and then
 do "virtual sampling" from the state vector, or to run the circuit and perform
 full simulated measurements each time.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__JointCNOT">
      <summary>
 Demonstrates and tests various ways of implementing CNOT from joint measurements
 and single-qubit Clifford gates.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__Noise1(System.Int32,System.Int32,System.Double)">
      <summary>
 Demonstrates the use of a complex noise model with error correction.
 See the Users Manual for more information.
 </summary>
      <param name="depth">The number of idle gates to include in the circuit.</param>
      <param name="iters">The number of executions to run, for statistical purposes.</param>
      <param name="prob">The probability of an error occurring.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__NoiseAmp">
      <summary>
 Demonstrates a complex noise model.
 See the Users Manual for more information.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__QECC">
      <summary>
 Demonstrates some examples of error correction and stabilizer simulation.
 See the Users Manual for details.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__QFTbench">
      <summary>
 Benchmarks the Quantum Fourier Transform at the heart of the Shor algorithm.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__QLSA">
      <summary>
 Demonstrates the Quantum Linear Algebra algorithm from 
 <see href="http://arxiv.org/abs/0811.3171">Harrow, Hassidim, and Lloyd</see>.
 See the Users Manual for more information.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__QuAM">
      <summary>
 Demonstrates the Quantum Associative Memory algorithm from
 <see href="http://arxiv.org/abs/quant-ph/9807053">Ventura and Martinez</see>.
 See the Users Manual for more information.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__QWalk(System.String)">
      <summary>
 Demonstrates the Quantum PageRank algorithm from
 <see href="http://arxiv.org/abs/1112.2079">Paparo and Martin-Delgado</see>.
 See the Users Manual for more information.
 </summary>
      <param name="which">The web graph to use. There are three built-in graphs:
 tiny, tree, and graph. Alternatively, the path to a .graph file may be provided.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__Ramsey33">
      <summary>
 Solves for the (3,3) Ramsey number.
 See <see href="http://arxiv.org/abs/1201.1842">this paper</see> for details.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__SG">
      <summary>
 Simulates a spin glass using a first-quantized Hamiltonian.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__Shor(System.Int32,System.Boolean)">
      <summary>
 Runs the classic Shor factoring algorithm.
 </summary>
      <param name="N">The number to factor.</param>
      <param name="doCirc">Whether or not to optimize the circuit.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__Steane7">
      <summary>
 Validates that the Steane 7 code is correct.
 See <see cref="M:Microsoft.Research.Liquid.Steane7.Test1">Steane7.Test1</see> for more details.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__Teleport">
      <summary>
 Renders and runs the classic quantum teleportation algorithm.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.__TSP(System.Int32)">
      <summary>
 Solves the traveling salesman problem.
 </summary>
      <param name="nCities">The number of cities to include in the map, from 5 to 8.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Tests.RenderTest(System.String,Microsoft.Research.Liquid.Circuit,Microsoft.Research.Liquid.Ket)">
      <summary>
 Renders and dumps test circuits in a variety of formats and detail levels.
 </summary>
      <param name="name">The base name for the output files.</param>
      <param name="circ">The Circuit to render.</param>
      <param name="ket">The state vector for the circuit.</param>
    </member>
    <member name="T:Microsoft.Research.Liquid.Util">
      <summary>
 General utilities used by the rest of the system
</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.__show(System.String)">
      <summary>
 Shows a line of output.
 This is a command line-callable routine.
 </summary>
      <param name="str">String argument to show</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Util.copyright">
      <summary>
 Copyright notice for Liquid.
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.getFlgPar(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Boolean)">
      <summary>
 Extracts a boolean macro definition from a command option dictionary.
 </summary>
      <param name="dic">The dictionary to search</param>
      <param name="nam">The macro name</param>
      <param name="def">The default value to return if the name is not found in the dictionary</param>
      <returns>Macro value if found, or else default value</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.getFltPar(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Double)">
      <summary>
 Extracts a float macro definition from a command option dictionary.
 </summary>
      <param name="dic">The dictionary to search</param>
      <param name="nam">The macro name</param>
      <param name="def">The default value to return if the name is not found in the dictionary</param>
      <returns>Macro value if found, or else default value</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.getIntPar(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Int32)">
      <summary>
 Extracts an integer macro definition from a command option dictionary.
 </summary>
      <param name="dic">The dictionary to search</param>
      <param name="nam">The macro name</param>
      <param name="def">The default value to return if the name is not found in the dictionary</param>
      <returns>Macro value if found, or else default value</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.getIntsPar(System.Collections.Generic.Dictionary{System.String,System.String},System.String,Microsoft.FSharp.Collections.FSharpList{System.Int32})">
      <summary>
 Extracts an integer list macro definition from a command option dictionary.
 </summary>
      <param name="dic">The dictionary to search</param>
      <param name="nam">The macro name</param>
      <param name="def">The default value to return if the name is not found in the dictionary</param>
      <returns>Macro value if found, or else default value</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.getStrPar(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String)">
      <summary>
 Extracts a string macro definition from a command option dictionary.
 </summary>
      <param name="dic">The dictionary to search</param>
      <param name="nam">The macro name</param>
      <param name="def">The default value to return if the name is not found in the dictionary</param>
      <returns>Macro value if found, or else default value</returns>
    </member>
    <member name="P:Microsoft.Research.Liquid.Util.outputPrefix">
      <summary>
 Global override for the prefix used for output functions (show and variants).
</summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.procStats(System.Boolean)">
      <summary>
 Gets current process memory usage statistics.
 </summary>
      <param name="doCollect">Do a garbage collection before reporting?</param>
      <returns>procStatsT struct</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.Random.Normal(System.Random,System.Double,System.Double)">
      <summary>
 Add a Normal distribution to the System.Random class.
 This is an extension method and may be used as if it were an instance method on Random.
 </summary>
      <param name="x">The instance of System.Random (ignore)</param>
      <param name="mean">Mean of returned value</param>
      <param name="sd">Standard deviation of returned value</param>
      <returns>Random Gaussian value</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.Random.PermAry(System.Random,System.Int32)">
      <summary>
 Create a random permutation array (call .permute with results)
 This is an extension method and may be used as if it were an instance method on Random.
 </summary>
      <param name="x">The instance of System.Random (ignore)</param>
      <param name="len">Length of array to create</param>
      <returns>Randomized array</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.show``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
      <summary>
 Shows a line of output to the console and the log file.
 </summary>
      <param name="fmt">printf format parameters</param>
      <typeparam name="a">Internal type of the printf string. The F# compiler will deduce this.</typeparam>
      <returns>Internal printformat.</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.showBareInd(System.Int32,System.String)">
      <summary>
 Shows an indented line of output, with no prefix, to the console and log file.
 This routine is used by or with various Dump() routines.
 </summary>
      <param name="level">The indentation level. 
 Each level represents a two space indent.</param>
      <param name="line">The text to show.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.showBareLogInd(System.Int32,System.String)">
      <summary>
 Shows an indented line of output, with no prefix, to the log file.
 This routine is used by or with various Dump() routines.
 </summary>
      <param name="level">The indentation level. 
 Each level represents a two space indent.</param>
      <param name="line">The text to show.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.showDump(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},System.String)">
      <summary>
 Dumps out a string with with an optional indentation.
 </summary>
      <param name="fO">The optional output function to use. 
 The default is <see cref="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">showLogInd</see>.</param>
      <param name="lO">The optional indentation level. The default is 0.</param>
      <param name="str">String to output</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.showInd(System.Int32,System.String)">
      <summary>
 Shows an indented line of output to the console and log file.
 This routine is used by or with various Dump() routines.
 </summary>
      <param name="level">The indentation level. 
 Each level represents a two space indent.</param>
      <param name="line">The text to show.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.showLog``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
      <summary>
 Shows a line of output to the log file.
 </summary>
      <param name="fmt">printf format parameters</param>
      <typeparam name="a">Internal type of the printf string. The F# compiler will deduce this.</typeparam>
      <returns>Internal printformat</returns>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.showLogInd(System.Int32,System.String)">
      <summary>
 Shows an indented line of output to the log file.
 This routine is used by or with various Dump() routines.
 </summary>
      <param name="level">The indentation level. 
 Each level represents a two space indent.</param>
      <param name="line">The text to show.</param>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.showProcStats(System.String)">
      <summary>
 Print process memory usage statistics to the console and log file.
 </summary>
      <param name="nam">Tag for this log entry, up to 12 characters</param>
    </member>
    <member name="P:Microsoft.Research.Liquid.Util.sqrt2">
      <summary>
  Highly accurate square root of 2, for use building unitary matrices.
 </summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.Util.LQDAttribute">
      <summary>
 Allows a function to be visable from a LIQUiD script or the command line
 </summary>
    </member>
    <member name="M:Microsoft.Research.Liquid.Util.LQDAttribute.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Microsoft.Research.Liquid.Util.LQDAttribute</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="T:Microsoft.Research.Liquid.Util.procStatsT">
      <summary>
 Current process memory usage statistics.
 Returned by the procStates function.
 </summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Util.procStatsT.peakVMMB">
      <summary>
 Peak virtual memory in megabytes
</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Util.procStatsT.peakWSMB">
      <summary>
 Peak working set in megabytes
</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Util.procStatsT.privMB">
      <summary>
 Private memory in megabytes
</summary>
    </member>
    <member name="P:Microsoft.Research.Liquid.Util.procStatsT.wsetMB">
      <summary>
 Working set in megabytes
</summary>
    </member>
  </members>
</doc>